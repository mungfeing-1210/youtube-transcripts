---
layout: post
title: "The Secrets of Claude Code From the Engineers Who Built It"
channel: "Every"
date: 2024-10-29
---

# The Secrets of Claude Code From the Engineers Who Built It

**频道**: Every
**发布日期**: 2025-10-29
**视频链接**: https://www.youtube.com/watch?v=IDSAMqip6ms

---

## Key Takeaways

## 一句话总结
本视频深入探讨了 Claude Code (Claude Code) 的设计理念、技术演进和独特之处，揭示了其作为下一代编程助手如何通过“无 IDE”的终端原生体验、强大的工具集成和“ant fooding”的开发模式，赋能开发者和 AI 协同工作，重塑编程范式。

## 内容概览
本视频由 Claude Code 的核心开发者深入剖析了其诞生的偶然性与必然性，重点介绍了 Claude Code 如何通过直接与终端交互，摒弃传统 IDE 的模式，以及模型驱动的工具使用（如 bash）如何成为其核心竞争力。视频还探讨了“ant fooding”（内部员工使用自家产品）的开发模式如何驱动产品迭代，并分享了 Claude Code 在“latent demand”（潜在需求）驱动下的产品演进，包括其作为通用 Agent SDK 的拓展性。

## 核心要点

### 1. 终端原生体验：颠覆性的“无 IDE”设计
**背景/问题**: 传统的 AI 编程助手通常集成在 IDE 中，提供代码补全或侧边栏辅助，用户需要频繁在编辑器和 AI 之间切换。
**核心观点**: Claude Code 选择了完全摒弃传统的文本编辑器，将 AI 完全置于终端环境中，让用户只需与终端交互即可完成编程任务。这种设计消除了中间层，使得 AI 拥有与工程师在终端中完全相同的访问权限。
**实践启示**: 这种“终端原生”的设计极大地简化了用户工作流，降低了 AI 辅助编程的门槛，并为 AI 提供了更直接、更强大的操作能力。开发者可以专注于任务本身，而非工具的切换。

### 2. 模型驱动的工具使用：bash 的强大集成
**背景/问题**: 许多 AI Agent 架构倾向于为模型构建定制化的工具集，但 Claude Code 却选择直接利用模型对 bash 的强大理解能力。
**核心观点**: Claude Code 的一个关键突破在于其能够直接使用 bash 命令来自动化任务，并能生成如 AppleScript 等脚本来完成复杂操作。模型“渴望”使用工具，而 bash 是一个极其强大且通用的工具。
**实践启示**: 这种方法大大简化了工具集成，降低了开发和维护成本，并充分发挥了大型语言模型的泛化能力。开发者无需为每个操作构建单独的 API，模型可以直接与操作系统交互。

### 3. “Ant Fooding”：以身作则驱动产品迭代
**背景/问题**: 如何确保产品真正满足开发者需求，并快速迭代以适应快速变化的技术和用户期望。
**核心观点**: Anthropic 内部将员工称为“ants”，而“ant fooding”即是内部员工（尤其是技术人员）日常使用 Claude Code 的行为。超过 70-80% 的技术员工每天都在使用，这带来了海量的实时反馈，使得产品能够快速发现问题、验证功能并进行迭代。
**实践启示**: 这种“以身作则”的开发模式是产品成功的关键驱动力。通过让团队成员成为最核心的用户，能够最真实地反映产品优劣，并加速创新。

### 4. Latent Demand 驱动的产品演进：从编程助手到通用 Agent SDK
**背景/问题**: 如何识别和满足用户未被满足的需求，并使产品具备长期的生命力和可扩展性。
**核心观点**: Claude Code 的发展遵循“latent demand”（潜在需求）的理念，即构建一个足够“hackable”和“open-ended”的产品，允许用户将其用于设计之初未预料到的场景，然后根据用户的滥用和创新来构建新的功能。
**实践启示**: 这种理念使得 Claude Code 从一个编程工具演变成一个通用的 Agent SDK (Claude Agent SDK)。用户发现其不仅可以用于编码，还可以用于写博客、市场研究、作为健康助手、财务分析师等，这证明了其底层原语的通用性。

### 5. Dual-Use Tools：兼顾人类与模型的工具设计
**背景/问题**: 如何设计工具，使其既能服务于人类开发者，也能被 AI 模型有效利用。
**核心观点**: Claude Code 的许多工具设计都是“dual-use”（双重用途）。例如，模型可以调用 `/commit` 命令来执行 Git 提交，这个逻辑对人类开发者同样有用。这种设计哲学使得工具更容易理解，并且能够共享逻辑。
**实践启示**: 将工具设计为双重用途，能够提升开发效率，减少重复工作，并促进人机协作的无缝衔接。

### 6. “Antfooding”的Bottom-Up创新：从个人需求到团队功能
**背景/问题**: 如何从日常开发中涌现出有价值的产品功能。
**核心观点**: Claude Code 的许多功能，如“bash mode”（`!` 前缀执行 bash 命令）、`todo` lists、sub-agents 等，都源于团队成员在日常使用中遇到的痛点或灵感，通过“bottom-up”的方式实现。
**实践启示**: 鼓励团队成员主动解决自己的问题，并将其转化为团队共享的功能，是激发产品创新的有效途径。这种自下而上的创新方式更能贴近真实需求。

### 7. 模块化与可扩展性：插件 (Plugins) 和 Hook 系统
**背景/问题**: 如何让 Claude Code 适应不同用户的个性化需求和复杂的开发环境。
**核心观点**: Claude Code 提供了高度的可扩展性，包括支持自定义 slash commands、hooks，以及通过 Plugins 系统来集成第三方服务和工具。
**实践启示**: 这种模块化的设计使得 Claude Code 能够作为一个平台，让用户和开发者构建自己的工作流和应用，极大地扩展了其应用场景。

### 8. Agentic Search vs. Vector Search：架构选择与权衡
**背景/问题**: 在处理大量代码和文档时，如何高效地进行信息检索。
**核心观点**: Claude Code 最初尝试过 vector embeddings，但发现其维护成本高且容易过时。最终选择了 agentic search，认为 Claude 模型本身在进行“agentic search”时表现出色，且部署更简洁。
**实践启示**: 这种选择突显了在 AI Agent 架构中，模型自身能力与外部工具/向量数据库之间的权衡。Agentic search 的优势在于其灵活性和模型集成度。

### 9. 复合式工程 (Compounding Engineering) 与知识内化
**背景/问题**: 如何打破传统工程中“越做越难”的困境，实现持续的效率提升。
**核心观点**: Anthropic 内部提倡“compounding engineering”，即通过将每一次开发过程中的学习和经验（如计划、测试、遗漏点）内化到 prompt、sub-agents 和 slash commands 中，使后续的开发变得更容易。
**实践启示**: 这种方法论强调知识的积累和复用，通过系统化的方式将人的经验转化为 AI 的能力，从而实现指数级的工程效率增长。

### 10. 谨慎的工具移除策略：保持简洁与高效
**背景/问题**: 随着模型能力的增强，如何优化工具集，避免过度复杂化。
**核心观点**: Claude Code 的工具集会根据模型能力的变化进行调整，有时会“unhip”（移除）不再必要的工具（如 OS tool），因为模型已经能够通过 bash 实现相同功能。同时，也保留了一些工具（如 search tool）用于 UX 和权限管理。
**实践启示**: 这种精简工具集的策略有助于降低模型的上下文负担，提高效率，并保持系统的清洁。

### 11. Power User Tips：提升 Claude Code 使用效率
**背景/问题**: 如何充分发挥 Claude Code 的潜力，避免常见误区。
**核心观点**: 强调 Plan Mode 的重要性，尤其对于新手。鼓励 AI 提问以促进头脑风暴。建议将 `settings.json` 检入代码库以管理权限和预授权命令。
**实践启示**: 掌握这些技巧可以显著提高 Claude Code 的成功率和用户体验，帮助用户更好地理解和利用 AI 的能力边界。

### 12. “Proactive Claude”：迈向更高级别的自动化
**背景/问题**: 如何将 AI 从被动任务执行者转变为主动的生产力助手。
**核心观点**: 团队正在向“proactive Claude”方向发展，即 AI 能够理解团队目标，主动提出建议，并生成初步代码。这标志着 AI 从完成特定任务到成为团队成员的转变。
**实践启示**: 这是 AI 助手发展的下一个重要阶段，预示着更深层次的自动化和生产力提升。

## 关键概念与资源
**核心概念**:
*   **Claude Code (Claude Code)**: Anthropic 开发的 AI 编程助手。
*   **Terminal-Native Experience**: 终端原生的用户体验，无 IDE 依赖。
*   **Dual-Use Tools**: 同时服务于人类和 AI 模型的工具。
*   **Latent Demand**: 潜在需求，用户会在产品中发现其未被设计的功能。
*   **Ant Fooding**: 内部员工使用自家产品的开发模式。
*   **Agentic Search**: 通过 AI Agent 进行搜索，而非纯粹的向量检索。
*   **Compounding Engineering**: 通过知识内化和复用，使后续开发更容易的工程模式。
*   **Sub-agents**: 更小的、专门化的 AI Agent，可组合执行复杂任务。
*   **Hooks**: 在 Claude Code 工作流的特定节点触发自定义逻辑。
*   **Plugins**: 用于集成第三方服务和工具的机制。

**工具/技术**:
*   **Claude Code (Claude Code)**
*   **Claude Agent SDK**
*   **Bash**
*   **AppleScript**
*   **Python**
*   **Playwright**
*   **Puppeteer**
*   **Sentry**
*   **Asana**
*   **GitHub**
*   **Vim**
*   **Haiku (model)**
*   **Sonnet (model)**
*   **Opus (model)**
*   **Vector Embeddings**

**推荐资源**:
*   **YC (Y Combinator)**: 提到其“解决自己的问题”的创业理念。
*   **Reddit**: 提到用户在 Reddit 上分享的 Sub-agent 创意。

## 目标受众
**最适合**:
*   **软件工程师**: 尤其是那些希望提高编码效率、探索 AI 辅助编程新范式，或对下一代开发工具感兴趣的开发者。
*   **AI 研究员和开发者**: 对 Agentic AI、模型与工具集成、Agent SDK 设计感兴趣的群体。
*   **产品经理和技术领导者**: 关注 AI 驱动的产品创新、开发流程优化和潜在市场需求挖掘的决策者。
*   **对 AI Agent 和自动化感兴趣的任何人**: 视频深入探讨了 AI Agent 的能力边界、实现方式和未来发展方向。

**价值场景**:
*   **了解 AI 编程助手的最新进展**: 学习 Claude Code 如何颠覆传统 IDE 模式。
*   **探索 Agentic AI 的实际应用**: 了解模型如何与工具（尤其是 bash）交互，以及 Agentic Search 的优势。
*   **学习产品设计和迭代的创新方法**: 理解“ant fooding”和“latent demand”如何驱动产品成功。
*   **思考未来开发者的工作方式**: 视频描绘了人与 AI 协同工作的未来图景。
*   **寻求提升个人或团队开发效率的解决方案**: 学习 Claude Code 的高效使用技巧和复合式工程理念。

## 延伸思考
1.  **Claude Code 的“终端原生”模式是否会成为主流，或者它是否会与其他 IDE 集成模式并行存在？其长期用户体验和学习曲线如何？**
2.  **随着模型能力的不断增强，Claude Code 的“工具箱”将如何演变？哪些定制化工具的需求会减少，又有哪些新型的“dual-use”工具会应运而生？**
3.  **“Compounding Engineering”和“Latent Demand”的理念能否推广到非 AI 领域的产品开发中？在非技术领域，如何系统化地将经验转化为产品优势？**

---

## 中文文稿

好的，这是一份根据您提供的英文视频字幕转录并优化后的高质量中文文稿：

**视频标题: Claude Code 的秘密：来自工程师的深度解析**

### Claude Code 的强大之处

**主持人**: Claude Code 之所以能如此出色，是因为它能够访问工程师在终端上能进行的一切操作。你所能做的一切，Claude Code 都能做到，中间没有任何阻碍。

**嘉宾**: 事实上，Anthropic 内部使用 Claude Code 的人数正在不断增加，很多人每月花费上千美元购买使用额度。我们看到了这种“重度用户”的行为模式。这正是 Y Combinator（YC）所倡导的理念：如果你能解决自己的问题，那么你更有可能解决他人的问题。

### 产品设计的“潜在需求”

**嘉宾**: 产品设计中有一个非常古老的概念叫做“潜在需求”（latent demand）。你构建一个产品，让它易于被“黑客式”地使用，足够开放，以便用户能够将其用于设计初衷之外的其他用途。你之所以这样做，是因为你大致知道市场对此有需求。

**主持人**: 你认为命令行界面（CLI）是最终的形态吗？一两年后，我们还会主要通过 CLI 使用 Claude Code 吗？还是会有更好的形式出现？

[音乐]

**主持人**: 本期播客由 Google 赞助。大家好，我是 Omar，Google DeepMind 的产品与设计负责人。我们刚刚在 AI Studio 中推出了改进的 Claude Code 体验，它允许你混合搭配 AI 能力，比以往任何时候都更快地将你的想法变为现实。只需描述你的应用，Gemini 就会自动为你连接正确的模型和 API。如果你需要灵感，点击“我运气不错”，我们将帮助你开始。前往 a.studio/build，创建你的第一个应用。

### Claude Code 的诞生与演进

**主持人**: Cat Boris，非常感谢你们的到来。

**嘉宾**: 感谢邀请。

**主持人**: 是的。嗯，对于不认识你们的人，你们是 Claude Code 的创造者。我发自内心地感谢你们，我太喜欢 Claude Code 了。

**嘉宾**: 听到这个我们非常开心。这是我们最想听到的。

**主持人**: 我想从我第一次使用它的经历开始聊起。大概是在 Sonnet 3.7 发布的时候，我用了它，然后我惊呼：“天哪，这是一种全新的范式，一种全新的代码思考方式。” 最大的区别在于，你们彻底摒弃了文本编辑器，你只需要对着终端说话，仅此而已。

**主持人**: 而之前 AI 编程的范式，之前的框架，通常是你在一个文本编辑器里，AI 在旁边，或者它只是一个补全功能。所以，请带我们回顾一下那个决策过程，那个构建这种新范式的架构过程。你们是如何思考的？

**嘉宾**: 我觉得最重要的一点是，这完全不是故意的。

**主持人**: 哦？

**嘉宾**: 我们可以说是“意外”地走到了这一步。当时我加入 Anthropic 时，我们还在不同的团队。当时有一个 Claude Code 的前身，叫做 Clyde（CL C cliop）。它是一个研究项目，启动需要一分钟，是一个非常笨重的 Python 程序，需要进行大量的索引和配置。

**嘉宾**: 我加入后，想提交我的第一个 PR（Pull Request），但我当时像个新手一样，手动写了代码，因为我完全不知道有任何工具可以使用。

**主持人**: 感谢你承认这一点。

**嘉宾**: 我当时不知道有更好的方法。然后我提交了 PR，但 Adam Wolf，我们团队当时的经理，也是我的上手伙伴，他直接拒绝了我的 PR，说：“你这是手写的？你在干什么？用 Clyde。” 因为他当时也在大量地使用 Clyde 进行开发。

**嘉宾**: 于是我尝试了 Clyde。我给它描述了任务，它竟然一次性完成了。当时用的是 Sonnet 3.5，所以即使是这种基本任务，我还是需要修复一些东西。而且那个框架非常老旧，生成代码花了五分钟。但它确实奏效了，我当时就惊呆了，意识到这竟然是可能的。这让我开始思考，也许我们真的不需要 IDE。

**嘉宾**: 后来，我开始使用 Anthropic API 进行原型开发，最简单的方式就是在终端里构建一个小应用，这样我就不用费心去构建 UI 了。我开始构建一个简单的聊天应用，然后我就想，也许我们可以做一些类似 Clyde 的事情。于是我开始构建一个小的 Clyde，结果它比预期的要有用得多，而且没费多少力气。

**嘉宾**: 我认为最大的突破是当我们开始赋予模型工具（tools）的使用能力时。它就开始使用工具了，这是一个令人难以置信的时刻。模型就是想使用工具。我们给了它 bash，它就开始使用 bash，编写 AppleScript 来自动化一些任务，以响应用户的问题。我当时觉得这太疯狂了，我从未见过这样的事情。因为当时我只用过 IDE，最多就是文本编辑、单行或多行补全之类的。所以，Claude Code 的诞生，就是这种原型开发和对可能性探索的融合，以一种非常粗糙的方式。

**嘉宾**: 结果它出奇地有用。我想，对我们来说也是如此。对我而言，大概是在 Sonnet 4、Opus 4 的时候，我才真正体会到那种“魔力”。我当时就想：“我的天，这东西真的管用。”

**主持人**: 这很有趣。所以，请谈谈那个“工具时刻”，因为我认为这是 Claude Code 的一个特别之处——它就是能写 bash，而且写得非常好。我想很多之前的 Agent（智能体）架构，或者即使是现在构建 Agent 的人，第一反应可能是：“好吧，我们要给它一个查找文件（find file）的工具，然后给它一个打开文件（open file）的工具。” 你会构建所有这些自定义的封装器来为你服务。

好的，这是根据您提供的英文视频字幕转录并整理成的中文文稿：

### Claude Code 的工具集

**问**: 知道所有代理可能想采取的不同操作，但 Claude Code 只使用 bash，而且在这方面做得非常好。那么，你们是如何看待从中学到的东西的？

**答**: 是的，我认为我们现在正处于这样一个阶段，Claude Code 实际上拥有大量的工具。我认为大概有十几个左右。我们实际上每周都会添加或移除工具。所以，这变化相当频繁。不过，今天确实有一个搜索工具。

我们这样做有两个原因。一是用户体验（UX），这样我们可以更友好地向用户展示结果，因为目前大多数任务仍然有人工参与。二是权限管理。所以，如果你在你的 Claude Code 的 `settings.json` 文件中设置了“不允许读取”，我们必须强制执行这一点。我们对 bash 强制执行，但如果我们有一个专门的搜索工具，可以更有效地做到这一点。

不过，我们确实希望精简工具，让模型保持简单。就像上周或前两周，我们取消了一个 OS 工具，因为过去我们需要它，但后来我们确实建立了一种方法来强制执行 bash 的这种权限系统。在 Bash 中，如果我们知道你不允许读取某个特定目录，Claude 也不能对该目录执行 OS 操作。由于我们可以一致地强制执行这一点，所以我们不再需要这个工具了。这样做的好处是，Claude 的选择更少，上下文中的内容也更少。

### 团队职责划分

**问**: 那么，你们团队是如何划分职责的？

**答**: 我认为 Boris 设定了技术方向，并且是我们许多已推出功能的 the product visionary（产品远见者）。我更倾向于扮演支持角色，以确保：第一，我们的定价和打包方案能引起用户的共鸣；第二，确保我们能顺利地将所有功能推向市场。从决定“好吧，这些原型是我们绝对应该内部测试的”，到设定内部测试的质量阈值，再到将其传达给我们的最终用户。

目前我们正在进行一些新的项目。我可以说，历史上 Claude Code 的很多功能都是自下而上构建的，比如 Boris 和许多核心团队成员都有关于待办事项列表、子代理、hooks 等的绝妙想法，这些都是自下而上的。随着我们计划扩展到更多服务，并将 Claude Code 带到更多地方，我认为其中很多是“好吧，让我们与客户交流，让工程师参与到这些对话中，并优先处理这些服务，然后逐一完成”。

### “Ant Fooding” 的含义

**问**: “Ant Fooding” 是什么意思？

**答**: 哦，“Ant Fooding” 是……

**问**: 哦，“Ant Fooding”。

**答**: 哦，它的意思是“Dog Fooding”（内部测试）。所以，Anthropic 的“Ant”。我明白了。是的，这是我们对内部员工的称呼，我们称他们为“Ant”。所以，“Ant Fooding” 是我们版本的“Dog Fooding”。在内部，我认为 70% 或 80% 的 Anthropic 技术员工每天都在使用 Claude Code。所以，每次我们考虑一个新功能时，我们都会将其发布给内部人员，并获得大量反馈。我们有一个反馈渠道，我认为每五分钟就会收到一条帖子。因此，你可以很快地了解到人们是否喜欢它，它是否有 bug，或者它是否不好，我们应该取消它。

你可以看出，一个正在构建东西的人一直在使用它来构建，因为它的易用性对于构建东西来说是合乎逻辑的，而这只有在你进行“Ant Fooding”时才会发生。是的。是的。我认为这是一种非常有趣的构建新事物的模式，就像自下而上地“我为自己做点什么”。

**问**: 能跟我讲讲吗？

**答**: 是的，Cat 也非常谦虚。我认为 Cat 在产品方向上发挥了很大的作用，它来自于团队的每个人。像这些具体的例子，实际上都来自于团队的每个人。待办事项列表和子代理是 Sid 做的。Hooks 是 Dixon 发布的。Plugins 是 Daisy 发布的。

所以，就像团队里的每个人一样，这些想法都来自每个人。因此，我认为对我们来说，我们构建了这个核心的代理循环和这种核心体验，然后团队里的每个人、团队外的人都在一直使用这个产品。因此，就有各种各样的机会来构建满足这些需求的东西。

例如，Bash 模式，你知道，那个感叹号，你可以输入 bash 命令。这大概是几个月前的事了，我当时正在使用 Claude Code，在两个终端之间来回切换，我觉得有点烦人。于是，我一时兴起，让 Squad 思考一些想法，就想到了这个感叹号 Bash 模式。然后我说，“太棒了，把它变成粉色的，然后发布吧。”它就做到了。而且，这仍然是一种持续存在的东西，现在你也可以看到其他人也在效仿。

**问**: 这很有趣，我之前竟然不知道。这非常有用，因为我总是不得不打开一个新的标签页来运行任何 bash 命令。所以你只需要输入一个感叹号，它就会直接运行，而不是通过所有的 Claude 东西来过滤。

**答**: 是的，Claude Code 也能看到完整的输出。

**问**: 有意思，太完美了。

**答**: 所以你在 Claude Code 视图中看到的任何东西，Claude Code 也能看到。

**问**: 好的，这真的很有意思。

**答**: 这在某种程度上是我们正在考虑的用户体验问题。过去，工具是为工程师构建的，但现在工程师和模型各占一半。所以，作为工程师，你可以看到输出，但这对模型来说也相当有用。这也是理念的一部分，一切都是双重用途。所以，例如，模型也可以调用斜杠……

好的，这是根据您提供的英文视频字幕转录并整理的高质量中文文稿：

### Claude Code 的秘密

**主持人**：那么，你有没有像 `/commit` 这样的斜杠命令（slash command），它会执行几个不同的步骤，比如 diff（差异比较）和生成一个合理的 commit message（提交信息），等等。我手动运行它，但 Claude 也可以帮我运行。这非常有用，因为我们可以共享这个逻辑。我们可以定义这个工具，然后我们都可以使用它。

**嘉宾**：是的。

**主持人**：在设计供双方使用的工具（dual-use tools）和只供一方使用的工具时，有什么区别吗？

**嘉宾**：出乎意料的是，它们是一样的。

**主持人**：好吧。

**嘉宾**：到目前为止是这样。

**主持人**：是的。我有点觉得，这种为人类设计的优雅设计，对于模型来说也同样适用。

**嘉宾**：所以，你只是在思考什么对你来说是合理的，而模型通常也会觉得合理，如果它对你来说是合理的话。

**嘉宾**：是的。我认为 Claude Code 是一个终端 UI（用户界面），并且运行得非常好的一个很酷的地方在于，Claude Code 可以访问工程师在终端上能够访问的所有内容。我认为，当涉及到工具是否应该供双方使用时，让它们供双方使用实际上能让工具更容易理解。这意味着，你所能做的一切，Claude Code 都能做。中间没有任何障碍。

**主持人**：是的，这很有意思。是的，有几个这样的决定。所以，它没有代码编辑器，它在终端里，所以它可以访问你的文件。而且它在你的电脑上，而不是在云端的一个虚拟机里。因此，你可以以一种可重复的方式使用它，你可以构建你的 Claude MD 文件，或者构建斜杠命令等等，它变得非常可组合（composable）和可扩展（extensible），从一个非常简单的起点开始。

**主持人**：我很好奇，你是如何看待的，对于那些想构建一个代理（agent）的人，可能不是 Claude Code，而是其他东西，如何获得那个简单的包，然后随着时间的推移变得非常强大？

**嘉宾**：对我来说，我首先把它看作是开发任何一种产品，你必须先为自己解决问题，然后才能为他人解决。这在 YC（Y Combinator）是教的，你必须从自己开始。所以，如果你能解决自己的问题，你更有可能解决他人的问题。我认为对于编码来说，在本地开始是合理的。而且现在我们在网上也有 Claude Code，所以你也可以在虚拟机中使用它，你可以在远程环境中使用它。这在旅途中非常有用，当你想要从手机上操作时。

**嘉宾**：这正是我们一步一步验证出来的。你可以在 GitHub 上使用 Claude。我每天都用它，比如上班路上，在红灯前，我可能不应该这样做，但我在 GitHub 上，在红灯前，然后我说“Claude，修复这个问题”等等。所以，能够从手机上控制它非常有用，这证明了这种体验。我不知道这是否对每种用例都有意义。对于编码，我认为从本地开始是正确的。但我不知道这是否对所有事情都适用。

**主持人**：明白了。你们都使用哪些斜杠命令？

**嘉宾**：`/commit`。

**主持人**：是的。

**嘉宾**：嗯，我认为 `commit` 命令让 Claude 更快地确切知道要运行哪些 bash 命令来完成提交。

**主持人**：对于不熟悉的人来说，`/commit` 命令是做什么的？

**嘉宾**：哦，它只是告诉它确切如何进行提交。

**主持人**：明白了。

**嘉宾**：你可以动态地指定，比如，这三个 bash 命令需要运行。

**主持人**：明白了。而且很酷的是，我们还有一个内置的模板系统（templating system）用于斜杠命令。所以我们实际上会提前运行 bash 命令，它们嵌入在斜杠命令中。你还可以预先允许某些工具的调用。所以，对于那个斜杠命令，我们说允许 `git commit`、`git push`、`gh`。这样，在你运行斜杠命令后，就不会再询问权限了，因为我们有一个基于权限的安全系统。然后它还使用了 Haikou，这很酷。它是一个更便宜、更快的模型。

**嘉宾**：是的，对我来说，我使用 `commit`，`commit PR`，`feature dev`，我们经常使用。所以，Sid 创建了这个，它很酷。它会一步一步地引导你构建东西。所以，我们提示 Claude 首先问我确切想要什么，比如构建规范。然后，它会构建一个详细的计划，然后创建一个待办事项列表，一步一步地进行。所以，这是一种更结构化的功能开发。

**嘉宾**：然后我认为我们可能经常使用的最后一个命令是，我们对所有的 PR（Pull Request）都进行安全审查（security review），还有代码审查（code review）。所以，Claude 在 Anthropic 内部进行所有的代码审查。当然，仍然需要人类批准，但 Claude 负责代码审查的第一步。这只是一个 `/code review` 命令。

**主持人**：明白了。是的。我真的很想深入探讨一些事情，比如如何制定一个好的计划？所以，关于功能开发（feature dev）的那部分，因为我认为有很多小技巧，我开始发现，或者公司里的每个人都开始发现，它们很有效，我想知道我们是否遗漏了什么。例如，一个在计划开发过程中不直观的步骤是，即使我不知道确切需要构建什么，我脑子里只有一个小句子，比如“我想要功能 X”，我只是让 Claude 实现它，不给它任何其他信息，然后看看它做了什么。

好的，这是根据您提供的英文视频字幕转录并整理的高质量中文文稿：

### 迭代开发与规划

这帮助我理解，哦，原来我真正想表达的是这个，因为它犯了许多不同的错误，或者说，它做了一些我意想不到的事情。然后我就会利用这种从“一次性开发”中获得的经验。

我会把它全部清除。然后，这能帮助我为实际的功能开发写出更好的规划文档（plan spec）。以前你绝不会这样做，因为仅仅是“放手一搏”（yolo）让工程师去开发一个你没有实际规划过的功能，成本太高了。

但是，因为 Claude 能够深入你的代码库并执行操作，你可以从中学习。这有助于指导你制定实际的计划。

### Claude 的使用模式

**问**: 我觉得也许我可以先开始，我也很好奇你是如何使用它的。

**答**: 我认为对我来说，可能有几种不同的模式。一种是原型开发模式。

### 原型开发

就像传统的工程原型开发一样，你想构建最简单的东西，能够触及所有系统，这样你就能大致了解这些系统是什么，有哪些未知之处，并能追踪整个过程。

我和 Dan 的做法完全一样，Claude 会先完成任务，然后我看看它在哪里出了错，接着我会让它直接丢弃并重新开始。只需按两次 Escape 键，回到之前的检查点，然后重试。

### 一次性任务与复杂功能开发

我认为还有另外两种任务类型。一种是 Claude 能够“一键完成”（one-shot）的任务，而且我对此非常有信心。所以我会直接告诉它，然后切换到另一个标签页，开启“自动接受”（auto accept）功能，然后去做别的事情，或者去处理我的其他 Claude 任务。

但同时，还有这种更复杂的“功能开发”。这些是过去可能需要花费工程师几个小时才能完成的任务。对于这类任务，我通常会切换到“规划模式”（plan mode），在它编写任何代码之前，先就计划达成一致。

### 模型演进与边界变化

我认为这其中真正困难的是，边界会随着每个模型而变化，而且变化方式有时令人惊讶。更新的模型更智能，因此你需要“规划模式”的边界被向前推移了一点。

以前你需要规划，现在不需要了。我认为这是一个普遍的趋势，即以前需要大量“脚手架”（scaffolding）的工作，随着更高级模型的出现，这些工作被推入了模型本身，模型会随着时间推移逐渐“吞噬”一切。

### 构建可持续的代理框架

**问**: 你如何看待构建一个代理框架（agent harness），而不会在三个月后，当新的 Claude 发布时，你发现自己花费了大量时间构建的东西被模型本身所取代？

**问**: 也就是说，你怎么知道该构建什么，而不是说“现在还不行，但下次就会奏效，所以我们不花时间在这上面”？

**答**: 我认为我们构建了大部分我们认为能提升 Claude Code 能力的东西，即使这意味着我们可能要在三个月后将其淘汰。如果可能的话，我们甚至希望在三个月后就能淘汰它。

目前，我们只想提供最优质的体验，所以我们不太担心“一次性工作”。

### 计划模式的未来

**问**: 有趣。举个例子，就像“规划模式”本身。我认为我们可能会在某个时候取消它，当 Claude 能够直接从你的意图中判断出你可能想先进行规划时。

**答**: 是的。或者，例如，我昨天刚从系统提示（system prompt）中删除了大约 2000 个 token，因为 Sonnet 45 已经不需要它们了。但 Opus 41 仍然需要。

### 模型选择的权衡

**问**: 那如果说，最新的前沿模型（frontier model）不需要它，但你又想让它更高效，因为用户很多，你可能不会对所有任务都使用 Opus 或 Sonnet 45。你可能会使用 Haiku。那么，为 Haiku 构建一个更复杂的框架，与不花时间在这上面，而是使用 Sonnet 并承担成本，同时专注于更前沿的开发之间，存在一个权衡。

**答**: 总的来说，我们将 Claude Code 定位为一项非常高端的产品。所以，我们的北极星（north star）是确保它在我们最强大的模型上能够出色地工作，目前就是 Sonnet 45。

我们正在研究如何让它在未来更小的模型上也能很好地工作，但这并不是我们的首要任务。

### 模型评估与集成优势

**问**: 你如何看待……你知道，我们经常会收到模型，非常感谢。我们经常在模型发布前就收到它们，我们的工作是弄清楚它到底好不好。在过去六个月里，当我在 Claude 应用中用新的前沿模型测试 Claude 时，很难立即判断它是否更好。

**问**: 但在 Claude Code 中很容易就能看出来，因为框架对你从模型中获得的性能影响很大。而你们在 Anthropic 内部构建 Claude Code，所以模型训练和你们构建的框架之间有着更紧密的集成，它们似乎真的在相互影响。

**问**: 那么，这在内部是如何运作的？拥有如此紧密的集成，你们能获得哪些好处？

**答**: 我认为最重要的一点是，研究人员会直接使用它。所以，当他们看到什么有效、什么无效时，他们就能进行改进。我们进行了大量的评估（eval）来沟通反馈，了解模型到底处于什么水平。

好的，这是根据您提供的英文视频字幕转录并整理后的高质量中文文稿：

### 挑战模型极限

**主持人**: 嗯，是的，存在这样一个前沿领域，你需要给模型一个足够困难的任务，才能真正触及模型的极限。如果你不这样做，那么所有模型都差不多。但如果你给它一个相当困难的任务，你就能分辨出差异。

### 子代理的应用场景

**问**: 你会使用哪些子代理（sub-agents）？

**答**: 嗯，我有几个。我有一个规划子代理（planner sub-agent）在使用。我还有一个代码审查子代理（code review sub-agent）。代码审查实际上是我有时使用子代理，有时使用斜杠命令（slash command）的场景。通常在 CI（持续集成）中，我会使用斜杠命令，但在同步使用时，我会用一个子代理来做同样的事情。

**问**: 嗯，这是一个好问题。是的，也许这是一种品味问题。我不知道。我不知道。嗯，我认为可能是当你同步运行时，稍微“分叉”（fork off）出上下文窗口（context window）会比较好，因为代码审查中发生的所有事情都与我接下来要做的事情无关。但在 CI 中，这并不重要。

**问**: 你会同时启动大约 10 个子代理吗？是为了什么？

**答**: 对我来说，我主要用于大型迁移。好的，这是个大问题。嗯，实际上我们有，我们有一个叫做 coder 的斜杠命令，它里面有很多子代理。其中一个步骤是“找出所有问题”，所以有一个子代理负责检查 `quadmd` 的合规性。另一个子代理会查看 Git 历史记录，了解正在发生什么。还有一个子代理会查找一些明显的 bug。然后我们会在之后进行一个“去重质量”的步骤。所以它们会找出很多东西，其中很多是误报。然后我们就会启动另外五个子代理，这些都只是用来检查误报的。最终结果非常棒，它能找出所有真正的问题，而没有误报。

### 个人费用报销的创新应用

**主持人**: 太棒了。我实际上也这样做。嗯，我一个非技术性的 Claude Code 用例是费用报销。比如，我现在在旧金山，所以我有很多费用。我用 Claude Code 构建了一个小项目，它使用了一个金融 API 来下载我所有的信用卡交易。然后它会判断，这些很可能是我需要报销的费用。然后我有两个子代理，一个代表我，一个代表公司。它们会“战斗”来确定实际的费用清单。就像一个审计子代理和一个“Pro Dan”子代理。所以，嗯，这种“对手处理器”（opponent processor）模式似乎很有趣。

**答**: 是的。是的，这很酷。我感觉当子代理刚开始流行的时候，真正启发我们的是，之前 Reddit 上有一个帖子，有人为前端开发、后端开发、设计、测试开发、项目经理等创建了子代理。这很有趣，感觉有点过于拟人化了。也许这其中有些道理，但我认为真正的价值在于“不相关的上下文窗口”（uncorrelated context windows），即有两个互不知道的上下文窗口，这很有意思，而且通常能获得更好的结果。你呢？你有没有使用什么有趣的子代理？

### 前端测试与大规模协作

**问**: 我一直在尝试一个在前端测试方面非常出色的子代理。它使用 Playwright 来查看所有客户端错误，并将它们拉进来，尝试测试应用程序的更多步骤。它还没有完全成熟，但我看到了希望，我认为我们可以将其打包到我们的插件市场（plugin marketplace）中。

**答**: 是的。绝对。我用过类似的东西，只是用了 Puppeteer，然后看着它构建东西，然后打开浏览器，然后说：“哦，我需要改变这个。”这简直是……“我的天哪。”

**主持人**: 是的，这真的很酷。我认为我们开始看到这种大规模的、多大规模的子代理的开端。我不知道他们称之为“集群”（swarms）还是什么。实际上，Anthropic 内部有越来越多的人每月花费大量的积分，你知道吗，每月花费超过一千美元。而且这个比例的人数正在快速增长。我认为最常见的用例是代码迁移。他们正在进行从框架 A 到框架 B 的迁移。有一个主代理，它会列出所有需要做的事情的待办事项列表，然后将任务分配给大量的子代理。所以你指示 Claude，是的，启动 10 个代理，然后一次处理 10 个，然后将所有东西都迁移过来。

**问**: 这很有意思。你说的这种迁移，能举一个具体的例子吗？

**答**: 我认为最经典的例子是 Lint 规则。你知道，有一些 Lint 规则要推出，但没有自动修复器，因为你知道，作为一个分析工具，它实际上无法做到，对它来说有点过于简单了。我认为其他一些是框架迁移，比如我们最近从一个测试框架迁移到了另一个。这是一个非常常见的场景，因为验证输出非常容易。

**主持人**: 我发现的一件事是，这既适用于我们内部的项目，也适用于开源项目。就像，如果你是一个正在构建产品的人，并且想要构建一个以前已经实现过的功能。也许一个人们可以理解的例子是……

好的，这是根据您提供的英文视频字幕转录和编辑后的高质量中文文稿：

### 代码复用与知识沉淀

在实现类似记忆（memory）的功能时，我们可能会需要实现很多东西。由于内部有许多不同的产品，你可以直接调用 Claude 的子代理（sub-agents），询问它们是如何实现这些功能的。这其中存在一种代码共享的可能性，你不需要通过 API 或直接询问他人，就能了解“我们是如何做到的”。

然后，你可以借鉴最佳实践来构建自己的代码。这一点同样适用于开源社区，因为有大量的开源项目，其中许多开发者可能已经在一项功能（比如记忆功能）上投入了一年的时间，并且做得非常出色。你可以从中学习到人们已经摸索出的模式，并选择性地实现它们。

### 版本控制与历史记录

完全可以。你也可以连接你的版本控制系统。如果你过去构建过类似的功能，Claude Code 可以利用这些 API，例如直接查询 GitHub，查找人们过去是如何实现类似功能的，并阅读相关代码，然后复制其中的相关部分。

### 日志与记忆的整合

那么，有没有利用日志文件（log files）的经验？比如，记录下“这是我实现它的完整历史记录”，这对 Claude 是否重要？你们是如何实现这一点，或者让它变得有用的？

有些人对此深信不疑。在 Anthropic 内部，有些人会要求 Claude Code 为他们完成的每一项任务都写一份特定格式的日记条目，记录它做了什么、尝试了什么、为什么没成功。甚至还有一些代理会回顾过去的记忆，并将其提炼成观察结果。

我认为这是一个新兴的、有潜力的模式，我们可以将其产品化。这是一个我们正在看到的、效果不错的新兴模式。我认为，仅仅依靠一次性的对话记录来“一次性”地赋予模型记忆，其难点在于很难判断某个特定指令在未来所有任务中的相关性。我们有一个经典的例子：如果我说“让按钮变成粉色”，我不希望你记住未来所有按钮都要变成粉色。因此，我认为从大量日志中提炼记忆，是一种更稳定地发现模式的方法。

### 抽象层级与模型检索

似乎你需要能够进行两种类型的记忆处理：一种是自上而下的总结，你知道某些信息在未来会很有用，并且能把握其适用的抽象层级。另一种是，很多信息，比如“让按钮变成粉色”这样的提交日志（commit log），可能因为无数种你事先不知道的原因而变得有用。因此，你也需要模型能够查找所有类似的过往记录，并在恰当的时候呈现出来。你们也在考虑这一点吗？

是的，我认为这方面确实有潜力。也许可以将其视为一种传统的记忆存储方式，比如向量数据库（vector database）之类的东西，你只需将所有信息输入系统，之后便是一个检索问题。随着模型越来越智能，它自然会开始这样做。我注意到，即使是 Sonnet 45 模型，在遇到困难时，也会自然地开始查找，就像我们之前讨论过的，它会自发地使用 Bash 命令，浏览 Git 历史记录，然后说：“哦，好吧，这是一种有趣的做法。”

### 复合式工程与知识内化

在我们开始录制之前，我们曾讨论过内部的一项实践，它彻底改变了我们的工程方式。我们内部的 Claude Code 构建了命令行界面（CLI）工具，并且我们有一种被称为“复合式工程”（compounding engineering）的工程范式。在传统的工程中，每增加一个功能，都会让添加下一个功能变得更难。而在复合式工程中，你的目标是让下一个功能比上一个功能更容易构建。

我们实现这一点的方式是，将我们构建功能过程中所有的学习经验进行编码。例如，我们是如何制定计划的，计划的哪些部分需要修改；在开始测试时，我们发现了哪些问题，遗漏了哪些方面。然后，我们将这些经验编码到所有的提示（prompts）、子代理和斜杠命令（slash commands）中。这样，下次有人做类似的事情时，系统就能捕捉到这些信息，从而使构建过程变得更容易。

这就是为什么我，例如，可以轻松地介入我们的一个代码库并开始高效工作，即使我对此代码库一无所知，因为我们已经建立了一个由我们实现过程中积累的全部学习经验组成的“记忆系统”。但我们不得不自己构建这个系统。我很好奇，你们是否在开发类似的功能，让 Claude Code 自动完成这个过程？

是的，我们正开始考虑这一点。有趣的是，我们刚从 Fiona 那里听到了同样的事情。她刚刚加入团队，是我们的经理。她已经有大约十年没有写过代码了。但在她的第一天，她就提交了 PR（Pull Request）。她表示：“是的，我不仅忘记了如何写代码，Claude Code 让重新上手变得非常容易，而且我也不需要花费时间去了解任何背景知识，因为我似乎已经知道了这一切。”

我认为这很大程度上与人们为 Claude Code 本身提交 PR 有关，而且我们的客户也告诉我们，他们经常做类似的事情。如果你看到一个错误，他们会说“将这个添加到 Claude MD 中，以便下次……”

好的，这是根据您提供的英文视频字幕转录并整理的高质量中文文稿：

### Claude 代码的秘密

**主持人**: 它会自动识别，你可以通过多种方式来“灌输”这种记忆。例如，你可以说“@Claude 添加到 ClaudeMD”。你也可以说“@Claude 编写一个测试”。这是一种确保代码不被破坏的简单方法。

**嘉宾**: 我现在再也不用为让别人写测试而感到内疚了，这真的太容易了。我认为我们几乎 100% 的测试都是由 Claude 编写的。如果测试不好，我们就不会提交。好的测试则会被保留。

**主持人**: 还有，我认为代码规范（lint rules）也是一个重要方面。对于那些需要频繁执行的检查，我们内部有很多代码规范规则。Claude 会 100% 地编写这些规则。这主要是通过“@Claude 在 PR 中编写这个代码规范”来实现的。

**嘉宾**: 是的，目前存在一个关于如何自动完成这项工作的问题。我认为 Cat 和我通常的看法是，我们看到了这种“超级用户行为”，第一步是让产品变得“可 hack”（hackable），以便最优秀的用户能够想出如何做这种新奇的事情。但真正困难的工作在于，如何将它推广给其他人。

**主持人**: 我把自己归类为“其他人”这一类。我不太会用 Vim，也没有那种花哨的 T-box 设置。我的设置相当普通。所以，如果你能做一个我能用的功能，那基本上就说明其他普通工程师也能用。

**嘉宾**: 这很有意思，能详细说说吗？因为我一直在思考如何让产品既具有可扩展性和灵活性，让超级用户能找到你从未想过的新用法，同时又足够简单，让任何人都能使用并高效地工作。而且，你还可以将超级用户发现的用法提炼到基础体验中。你是如何做出这些设计和产品决策来支持这一点的？

### 可扩展性与插件

**主持人**: 总的来说，我们认为每个工程师的环境都是略有不同的，所以我们系统的每个部分都必须是可扩展的。这包括从状态行（status line）到添加自定义斜杠命令（slash commands），再到钩子（hooks），后者允许你在 Claude 代码的几乎任何一个步骤中插入一些确定性逻辑。我们认为这些是我们提供给每位工程师的基本构建块，供他们随意使用。

**嘉宾**: 关于插件（Plugins），它实际上是由我们团队的 Daisy 开发的。这是我们努力让普通用户（比如我们自己）更容易将这些斜杠命令和钩子融入工作流程的一种尝试。插件允许你浏览现有的斜杠命令、钩子和插件，然后只需在 Claude 代码中输入一个命令，就能将它们引入自己的工作流程。

### 潜在需求驱动产品

**主持人**: 产品领域有一个非常古老的想法，叫做“潜在需求”（latent demand）。我个人思考产品和下一步要做什么时，很大程度上依赖于这个概念。这是一个非常简单的想法：以一种“可 hack”的方式构建产品，使其足够开放，人们可以滥用它来满足其未被设计的其他用途。然后，你观察人们如何滥用它，并为之构建产品，因为你知道那里存在需求。

**嘉宾**: 在 Meta 工作时，我们就是这样构建所有大型产品的。我认为几乎每一个大型产品都蕴含着这种潜在需求的萌芽。举个例子，像 Facebook Dating，它的诞生源于这样一个想法：当我们观察谁在查看他人资料时，发现 60% 的浏览者是异性之间、非朋友关系的人。于是我们想，也许我们可以推出一个约会产品来利用这种已有的需求。

**主持人**: 这很有意思。对于 Marketplace 也是类似的。当时 Facebook 群组里大约 40% 的帖子是二手交易帖。所以我们想，人们正试图用这个产品来买卖东西，我们不如围绕它构建一个产品，这可能会奏效。

**嘉宾**: 我们思考方式也很相似，但我们有幸为开发者构建产品。开发者喜欢“ hacking”和定制。作为我们自己产品的用户，这让构建和使用这个工具变得非常有趣。就像我之前说的，我们构建了合适的扩展点，观察人们如何使用它们，这就能告诉我们下一步该构建什么。

**主持人**: 例如，我们收到了很多用户请求，他们说：“天哪，Claude Code 总是向我索要各种权限，而我正在外面喝咖啡，根本不知道它在索要权限。我怎样才能让它在 Slack 上通知我呢？”于是我们开发了钩子（hooks）。Dixon 开发了钩子，这样人们就可以在 Slack 上收到通知，而且可以为任何你想收到通知的事情设置提醒。

**嘉宾**: 这非常符合人们真正想要某种能力，而我们又不想自己去构建集成。所以我们暴露了钩子，让人们可以自己实现。

**主持人**: 这让我想起，你们最近将 Claude Code 的定位从之前的描述，转变为一个更通用的“Agent SDK”。这是不是也是由某种潜在需求驱动的，你们似乎看到了一个更通用的使用场景？

好的，这是根据您提供的英文视频字幕转录并整理的高质量中文文稿：

### Claude Code 的非传统应用

**主持人**: 我们意识到，就像您之前提到的，Claude Code 的用途远不止于编写代码。我们看到很多人用它来帮助撰写博客文章，管理数据输入，并进行初稿的撰写。

**嘉宾**: 是的，我们发现人们用它来构建电子邮件助手。我个人也经常用它进行市场调研。因为 Claude Code 的核心是一个智能代理，只要给它一个明确的任务，它就可以无限期地运行，并且能够获取所需的底层数据。

**主持人**: 举个例子，您之前在做什么项目？

**嘉宾**: 我当时想统计全球所有公司的工程师数量，并创建一个排名。这虽然不是传统的编码用例，但 Claude Code 也能做到。我们发现，只要有一个能够长时间运行的代理循环，并且能够访问互联网、编写和运行代码，那么通过一些巧妙的设计，几乎可以构建出任何东西。

### 内部与外部的广泛应用

**主持人**: 在我们将 Claude Code SDK 更名为 Claude Agent SDK 时，已经有数千家公司在使用它了，其中很多用例都与编码无关。这在我们内部和外部都得到了印证。

**嘉宾**: 是的，例如健康助手、金融分析师、法律助理等等。应用范围非常广泛。

**主持人**: 哪些用例最让您印象深刻？

**嘉宾**: 我觉得您最近在播客中采访的 Noah Brier 提到的 Obsidian 笔记和思维导图的用法就非常酷。很多人使用 Claude Code 来实现这个特定的组合，这真是令人惊叹。

**嘉宾**: 还有一些与编码相关或接近的有趣用例。比如我们有一个 Claude Code 的问题追踪器。团队经常忙得不可开交，需要处理涌入的大量问题。Claude Code 可以自动查找重复的问题，而且在这方面做得非常出色。

**嘉宾**: 它还能进行初步的问题解决。通常，当出现一个问题时，它会主动提交一个内部的 Pull Request。这是团队成员 Enigo 最近开发的一个新功能，非常棒。

**嘉宾**: 此外，还有关于值班和收集其他地方信号的功能，比如获取 Sentry 日志和 BigQuery 的日志，并将它们整合起来。Claude Code 在这方面表现优异，因为归根结底，这些都只是 shell 脚本（bash）而已。

### 持续运行与未来展望

**主持人**: 这些都是您看到的内部用例。那么，当它整合日志或处理问题时，是让 Claude 持续在后台运行吗？还是有其他触发机制？

**嘉宾**: 对于特定的用例，它会在有新问题提交时被触发。它会运行一次，但可以根据需要持续运行更长时间。

**主持人**: 明白了。那关于 Claude 持续运行的想法，也就是“主动式 Claude”呢？

**嘉宾**: 我认为这是我们未来的发展方向。目前，我们非常专注于让 Claude Code 在处理单个任务时做到极致的可靠性。如果您回溯一下这个发展曲线：从多行代码自动补全，到单轮对话代理，再到我们现在正在开发的能够完成任务的 Claude Code。

**嘉宾**: 最终，我们会走向更高层次的抽象，处理更复杂的任务。希望下一步能够极大地提升生产力。例如，理解团队的目标和您的目标，然后主动提出“我认为您可能想尝试这个功能”，并提供一个初步的代码实现，同时说明您做出的假设，并询问这些假设是否正确。

**主持人**: 我非常期待。

**嘉宾**: 我觉得紧随其后的是，Claude 将成为您的经理。

**主持人**: （笑）这不在计划之内。

**嘉宾**: 团队里的每个人都对我们今天的谈话感到非常兴奋，他们给了我很多问题，我想确保都问到。

### Agentic RAG 架构的选择

**主持人**: 哦，这是个好问题。为什么在您的架构中选择 Agentic RAG（检索增强生成）而不是向量搜索？向量嵌入是否仍然相关？

**嘉宾**: 实际上，我们最初确实使用了向量嵌入。但它们非常难以维护，因为您需要不断地重新索引代码，而且代码可能会过时，本地的更改也需要同步。

**嘉宾**: 当我们考虑外部企业如何采用时，我们意识到这会暴露更多的接口和安全风险。我们还发现，Claude Code 和 Claude 模型在 Agentic Search（代理式搜索）方面表现非常出色。

**嘉宾**: 也就是说，通过 Agentic Search 可以达到与向量嵌入相同的准确度，而且部署起来更简洁。

**主持人**: 这确实很有意思。

**嘉宾**: 如果您确实想为 Claude Code 引入语义搜索，可以通过 MCP 工具来实现。您可以管理自己的索引，并公开一个允许 Claude Code 调用它的 MCP 工具，这样就可以实现。

### 推荐的 MCP 工具与高级技巧

**主持人**: 您认为哪些 MCP 工具最适合与 Claude Code 一起使用？

**嘉宾**: Puppeteer 和 Playwright 绝对是名列前茅的。

**主持人**: 确实如此。

**嘉宾**: Century 和 Asana 也都有非常好的 MCP 工具。

**主持人**: 您认为在 Anthropic 内部或在其他组织中，是否有 Claude Code 的高级用户知道但普通用户不知道的技巧？

**嘉宾**: 有一点是 Claude Code 本身不太自然会去做的，但……

好的，这是根据您提供的英文视频字幕转录并整理的高质量中文文稿：

### 善用Plan Mode

我个人觉得非常有用的一个功能是，Claude Code（Claude Code）本身并不倾向于主动提问。但如果你把它当作一个思想伙伴或协作者来头脑风暴，通常你们之间会进行来回的提问。

所以，这是我喜欢做的一件事，尤其是在 Plan Mode（计划模式）下。我会直接告诉 Claude Code：“嘿，我们正在头脑风暴一个事情。如果你有任何不确定的地方，请尽管问我。” 我希望它能提出问题，它也会这样做。我认为这实际上能帮助你得到一个更好的答案。

### 常见误区与建议

关于Claude Code，有很多技巧可以分享。我认为人们会犯一些非常普遍的错误。其中一个就是，正如你所说，没有充分利用 Plan Mode（计划模式）。这一点至关重要。我认为那些刚接触编程的人，可能会想当然地认为它能做任何事，但事实并非如此。它今天还不够完美，未来会更好，但目前它只能“一键解决”一些测试，却无法“一键解决”大多数问题。

所以，你必须了解它的局限性，以及你需要在什么地方介入。像 Plan Mode（计划模式）这样的功能，如果能先制定好计划，就能轻易地将成功率提高两到三倍。

### 企业级部署与配置

我看到一些高级用户做得非常好的地方是，那些拥有大规模 Claude Code（Claude Code）部署的公司。幸运的是，这样的公司现在很多，我们可以从中学习。将 `settings.json` 文件纳入代码库进行管理非常重要，因为你可以用它来预先允许某些命令，这样你就不会每次都被提示权限问题。同时，你也可以阻止某些命令，比如你不想使用网络抓取（web fetch）之类的功能。这样，作为工程师，我就不会被反复打扰，并且可以将这个配置共享给整个团队，让每个人都能使用。

**问**：我通过直接使用“dangerous”（危险模式）来跳过权限提示来解决这个问题。

**答**：是的，我们这里也有类似的做法，但我们并不推荐。毕竟，它是一个模型，它有时会做出一些奇怪的事情。

### Stop Hooks 的高级用法

我认为另一个很酷的用例是人们利用 Stop Hooks（停止钩子）来做一些有趣的事情。Stop Hook（停止钩子）会在每次对话轮次（turn）完成后运行。也就是说，当助手与你进行了某些工具调用（tool calls）并完成，将控制权交还给你之后，我们就会运行 Stop Hook（停止钩子）。

你可以定义一个 Stop Hook（停止钩子），例如：“如果测试不通过，就返回文本并继续执行”。本质上，你可以让模型不断尝试，直到任务完成。当与 SDK（软件开发工具包）和这种程序化使用结合时，这简直太棒了。你可以让一个随机性、非确定性的事物，通过脚手架（scaffolding）获得确定性的结果。

### CLI 的未来形态

**问**：你们启动了这种 CLI（命令行界面）的范式转变。你认为 CLI 是最终的形态吗？一到三年后，我们还会主要在 CLI 中使用 Claude Code（Claude Code），还是会有其他更好的形式？

**答**：它不是最终的形态，但我们非常专注于让 CLI 变得尽可能智能，并且高度可定制。

**问**：你能谈谈未来的形态吗？

**答**：是的，我想说的是，因为没人知道这些东西发展得有多快，所以没人能确切地说出未来的形态是什么。目前，我认为我们的团队正处于实验阶段。我们有 CLI，然后推出了 IDE（集成开发环境）扩展。现在我们有一个新的 IDE 扩展，它是一个 GUI（图形用户界面），更容易上手。我们还推出了 GitHub App，你可以将 Claude Code（Claude Code）添加到任何地方。现在，Claude Code（Claude Code）有 Web 和移动端版本，你可以在任何地方使用它。我们正处于实验阶段，试图找出下一步的方向。

### 长期自主性与新形态

我认为，如果我们放眼全局，看看这些技术的发展方向，一个重要的趋势是更长的自主运行时间。对于每一个模型，我们都会测试它能自主执行任务多长时间。在“危险模式”（dangerous mode）下，在一个容器里，它可以持续运行直到任务完成。现在，这个时间已经可以达到两位数的小时，最新的模型大约是 30 小时。而下一个模型可能会达到数天。

当你考虑模型的并行处理时，会涌现出一系列问题。其中一个就是模型运行的容器是什么，因为你不可能一直守着你的笔记本电脑。我现在就面临这个问题，因为我正在进行大量的 DSPY 或 prompt 优化，而这一切都在我的笔记本电脑上运行。我不想合上它，我正处于中间状态，笔记本电脑开着，因为我不想合上它。

**问**：是的，没错。我们之前拜访过一些公司，客户们都带着他们的笔记本电脑到处走，问：“Claude Code（Claude Code）还在运行吗？”

**答**：所以，我认为一方面是要摆脱这种模式。另一方面，我认为很快我们就会进入“Claude Code（Claude Code）监控 Claude Code（Claude Code）”的模式。

**问**：嗯。

**答**：我不知道这方面的最佳形态是什么，因为作为人类，你需要能够检查它，了解发生了什么。但同时，它也需要是 Claude Code（Claude Code）优化的，即优化 Claude Code（Claude Code）之间通信的带宽。所以，我的预测是，终端（terminal）不是最终的形态。我的预测是，在接下来的几个月，也许一年左右的时间里，会出现几种新的形态，而且它会快速变化。

**问**：你认为……我教了很多 Claude Code（Claude Code）给很多人……

好的，这是根据您提供的英文视频字幕转录并整理的高质量中文文稿：

### 终端的挑战与易用性

**主持人**: 感谢每一位订阅者。

**嘉宾**: 不客气。我们为你做了很多工作。我认为一个很大的障碍是终端本身就令人望而生畏。就像在和订阅者通话时，我需要解释如何打开终端，以及即使是非技术人员也可以使用它，这本身就是一件大事。你对此怎么看？

**嘉宾**: 是的，我团队里的一位市场营销人员，因为她写的一些内容涉及 Cloud Code，所以开始使用它。我当时就说，你真的应该体验一下。结果她屏幕上弹出了大约 30 个权限请求，因为她以前从未用过终端。所以，我完全理解你的感受。

**嘉宾**: 对于非工程师来说，这确实很难。我们发现，甚至有些工程师也不完全习惯在终端中日常工作。我们推出的 VS Code GUI 扩展是朝着这个方向迈出的第一步，因为你完全不需要考虑终端。它就像一个传统的界面，有很多按钮。我认为我们还在开发更多图形化界面。Cloud Code 在 Web 上的版本就是一个 GUI。我觉得这可能是一个很好的起点，适合那些技术背景较弱的人。

### 意外的用户群体

**主持人**: 是的，是的。大概几个月前，有一个很神奇的时刻。我走进办公室，发现 Anthropic 的一些数据科学家就坐在 Cloud Code 团队旁边。其中一位数据科学家就在他的电脑上运行着 Cloud Code。我当时就想，“这是什么？他是怎么做到的？”

**嘉宾**: 我想是 Brandon 最先做到的。他说：“哦，我只是安装了它。我做这个产品，理应使用它。” 我当时就惊呆了。他竟然学会了如何使用终端和 JavaScript，尽管他以前并没有真正做过这类工作流程。当然，他本身就非常技术性强。

**嘉宾**: 所以，我感觉现在我们开始看到各种“代码邻近”的功能。这些人也在使用 Cloud Code。从潜在需求的角度来看，这很有趣。这些人正在“黑客式”地使用这个产品，这表明存在使用它的需求。因此，我们希望通过更易于访问的界面让它变得更容易。但同时，对于 Cloud Code 本身，我们专注于为最优秀的工程师打造最好的产品。所以，我们专注于软件工程，希望把它做得真正出色，但也希望它能被其他人“黑客式”地使用。

### 代码简化与用户反馈

**主持人**: 有时候 Cloud Code 会生成一些稍微冗长的代码。

**嘉宾**: 但你可以直接让它简化，它做得非常好。

**主持人**: 有趣。那么，你是如何以及何时做到这一点的？你是使用斜杠命令（slash command）还是直接说？

**嘉宾**: 我直接说。

**主持人**: 有时候你会说：“嘿，这应该是一行代码的修改，结果它写了五行。”然后你说：“简化它”，它会立刻理解你的意思并进行修正。

**嘉宾**: 是的，我们团队里很多人也这样做。这很有意思。为什么不，既然你经常这样做，为什么不把它变成一个斜杠命令或者集成到其他地方，让它自动发生呢？

**嘉宾**: 我们在 Cloud MD 中有相关的说明。我认为这种情况只影响很小一部分对话，我们不想让它过度影响其他方面。至于为什么不是斜杠命令，是因为你其实不需要太多上下文。我认为斜杠命令适用于你原本需要写两三行才能完成的情况。但对于像 Plan Mode 这样的功能，你确实可以用几个词来表达，但有时需要两三行才能完整表达你的意图。而对于“简化它”，你只需要说“简化它”，它就能明白。

**主持人**: 是的，是的，这说得通。太好了。

**嘉宾**: 是的。

### 早期阶段与持续演进

**主持人**: 好的，我们现在可以……这很有意思。是的，但这些东西感觉还是非常早期。

**嘉宾**: 是的。

**主持人**: 你知道，我们在录制前还在讨论，我们现在处于采用曲线的哪个阶段。

**嘉宾**: 是希腊曲线（Hian curve）还是什么别的术语？

**主持人**: 正是如此。感觉我们还在最初的 10%。这些东西变化会非常快，而且会持续变化。即使我与 Anthropic 之外的研究人员交流，他们也在使用 Cloud Code，他们也会遇到类似的问题，比如没有意识到可以直接让 LLM 简化代码。这表明，即使是这个行业里的人，也不总是意识到你可以直接与模型对话。

**嘉宾**: 关键在于，我认为存在一种潜在的期望，即使用 AI 不应该需要一项技能，因为它会按照你的指令行事。但实际上，你说的话对它的行为至关重要。所以，如果你能更好地表达，它就会做得更好。

**嘉宾**: 是的，但这一点随着模型的每一次更新都在变化。这才是最难的部分。比如，“提示工程师”（prompt engineer）曾经是一个职业，但现在已经不是了。未来还会有更多这样的“微技能”消失，因为模型会变得越来越好，能够更好地理解。

**嘉宾**: 但我认为，这也是我们构建这类产品时必须保持的一种谦逊。我们真的不知道接下来会发生什么，我们只是和大家一起摸索。我们只是在体验这个过程。

**主持人**: 这就是为什么你为自己构建它而感到高兴，因为我认为……

好的，这是根据您提供的英文视频字幕转录和整理的中文文稿：

### 开发者即用户

**主持人**: 了解 Claude Code 的最佳方式，就是像我们一样，一直在使用它，仿佛生活在未来。当你经常使用它时，缺失的功能就一目了然了。你会想：“我就是需要这个功能”，然后就能直接实现。这比去问那些大型企业里的产品经理：“你们想要什么样的 AI 功能？”要好得多。他们可能会说：“我不知道，也许在我的 IDE 旁边放个小聊天机器人吧。”

**嘉宾**: 是的。这就是开发工具的优势所在，你就是自己的客户。我认为 AI 也是如此，它重置了所有软件的规则。

### AI 带来的创新机遇

**嘉宾**: 比如我们有 Kora，一个邮件助手；还有 Sparkle，用于整理文件。任何你在电脑上需要使用的东西，如果用 AI 来构建，很可能都是前所未有的，因为整个格局都被重塑了。所以，这是一个非常令人兴奋的创造新事物的时代。

**嘉宾**: 完全同意。它彻底打开了竞争的大门。任何个人都可以开发一款应用来满足自己的需求，然后分发给所有人。

**嘉宾**: 这真的很酷。我一直在尝试各种各样的小项目。我刚搬进一个新公寓，里面空空荡荡。我一直在用 Claude Agent SDK 构建一个购物顾问助手。谁有时间去读所有评论、比较所有选项、查找价格？一切都很难发现。

**嘉宾**: 这个助手会问我一系列问题，我告诉它我想要什么，它就会展示各种沙发和选项的图片，以及网上人们的评价。

**嘉宾**: 然后我告诉它我不喜欢什么，它真的就像在和一个购物助手一起工作一样。这太棒了。

**嘉宾**: 我还有一个小小的邮件回复助手，可以帮我起草回复。不过我不太用邮件。

**嘉宾**: 哦，我就知道不是你本人在回复。

**嘉宾**: 所以才延迟了七天。助手只是在非常认真地工作。

**嘉宾**: 是的，助手 SDK 确实很棒。

**嘉宾**: 是的，助手 SDK 很棒。

### 团队协作与演示文化

**嘉宾**: 感觉我们能用这么小的团队做出这么多东西，真是太神奇了。

**嘉宾**: 另一个很酷的点是，我认为人们正在从“文档驱动”转向“演示驱动”。在我们内部，真正的“货币”是演示。你希望人们对你的东西感到兴奋。

**嘉宾**: “给我们展示一下它能做什么，哪怕只有 15 秒。”我们发现团队里的每个人现在都有这种“演示文化”。我认为这更好，因为很多你头脑中的想法，如果你是个优秀的作家，也许能解释清楚，但仍然非常困难。

**嘉宾**: 但如果别人能看到，他们就能立刻理解。我认为这不仅适用于产品开发，也适用于各种其他创意领域，比如制作电影。以前你需要写提案，但现在你可以直接说：“我做了这个 Sora 视频”，然后人们就能看到你想要制作的东西的雏形，而且成本很低。

**嘉宾**: 这意味着你不需要花太多时间去说服别人，可以直接说：“看，我做出来了。”

**嘉宾**: 而且作为开发者，你可以直接动手去做，然后不断改进，直到满意为止。我感觉，以前我们只能写文档、在白板上画图，或者用 Sketch 或 Figma 来绘制草图。现在我们可以直接构建，直到我喜欢它的感觉。

**嘉宾**: 现在要获得这种感觉太容易了。以前你可以从视觉上看到，或者用语言描述，但你永远无法抓住那种“氛围”。现在，这种“氛围”变得非常容易捕捉。

**嘉宾**: 你因为这个（指 AI 的易用性）把 Plan Mode 重建了三次。

**嘉宾**: 是的。你建好它，然后又放弃，再重建，再放弃，再重建。

**嘉宾**: 就像 Tudos 的 Sid，他构建了最初的版本，也经历了三四次原型开发。然后我可能在一天之内就原型开发了 20 个版本。

**嘉宾**: 是的，我认为我们发布的几乎所有东西，背后都有至少几个原型。

### 原型迭代与学习传承

**主持人**: 你是如何在原型之间跟踪和传承你学到的东西的？特别是如果一个人在原型开发，然后另一个人接手，进行 20 次迭代，你如何最大化从这个过程中获得的收益？

**嘉宾**: 这其中可能有几个要素。一个是指南（style guide）。我们发现了一些设计风格。我认为很多是关于为终端（terminal）构建，我们正在为终端发现一种新的设计语言，并随着开发不断完善。

**嘉宾**: 有些东西可以被编码进风格指南，比如我们的 quad MD。但还有一部分是关于“产品感觉”（product sense）。我认为模型目前还没有完全理解。也许我们应该想办法教会模型这种“产品感觉”，即“这个可行，那个不行”。

**嘉宾**: 因为在产品开发中，你希望以最简单的方式解决用户的问题，然后删除所有不必要的东西。

好的，这是根据您提供的英文视频字幕转录并编辑后的高质量中文文稿：

### Claude Code 的核心理念

**主持人**：我们现在就来深入了解 Claude Code 的一些细节。

**嘉宾**：Claude Code 的核心在于，我们努力将产品与用户的意图尽可能清晰地对齐。即使模型当下可能还未能完全理解用户的全部意图。

**主持人**：是的，模型本身并不能真正体会使用 Claude Code 的感受，因为它并不直接使用 Claude Code。

**嘉宾**：没错。所以，我认为当你知道 Claude Code 可以进行自我测试，并且可以某种程度上“使用”自己时，这在开发过程中非常有用。它可以发现 UI 上的 bug 等等。

**主持人**：也许我们应该尝试一下提示（prompting）的方式。很多时候，事情就这么简单。当出现一个新想法时，你通常只需要给模型一个提示，它往往就能给出不错的结果。或许我们应该就这么试试。

### 交互设计的演进

**嘉宾**：很多原型实际上都是围绕着用户体验（UX）的交互方式来设计的。一旦我们发现了一种新的 UX 交互方式，比如 Boris（后来更正为 Eigor）发现的“Shift + Tab”用于自动接受（auto accept）。

**主持人**：哦，是 Eigor。

**嘉宾**：是的，我们为此来回尝试了一周，进行了“对决式原型”的开发。

**主持人**：Shift + Tab 的感觉确实很棒。而现在我们正在迭代的计划模式（plan mode）就使用了 Shift + Tab，因为它实际上是另一种告诉模型它应该有多大自主性（agentic）的方式。

**嘉宾**：因此，当越来越多的功能使用相同的交互方式时，你就能形成一个更强的心理模型，知道什么应该放在哪里。

### “思考”功能的诞生与优化

**嘉宾**：或者说，“思考”（thinking）功能也是一个非常好的例子。在 Claude Code 发布之前，或者说第一个“思考”模型大概是 37 版本？我记不清具体是哪个了。

**主持人**：是的。

**嘉宾**：它能够进行思考，我们当时在头脑风暴如何“切换”思考功能。然后有人提议：“如果我们直接让模型用自然语言来表达它的思考过程，它不就知道该怎么做了吗？”我们觉得这个主意太棒了，于是就这么做了。

**嘉宾**：我们这样实践了一段时间，然后发现用户会不小心触发它。比如，用户说“不要思考”，但模型却理解为“哦，我应该思考”，然后就开始思考了。

**嘉宾**：所以我们不得不进行调整，让“不要思考”不再触发它。但即便如此，用户体验仍不够直观。后来我们又进行了一次 UX 改进，通过高亮显示思考过程来让用户更清楚。

**主持人**：那段经历非常有趣，感觉很神奇。

**嘉宾**：是的，当你使用“超强思考”（ultra think）时，界面会变成彩虹色，或者类似的效果。

**嘉宾**：而且，随着 Sonnet 45 的推出，我们发现当开启“扩展思考”（extended thinking）时，性能有了非常显著的提升。因此，我们让切换它变得非常容易。因为有时候你想要它，有时候你又不想要。对于一个非常简单的任务，你不可能让模型思考五分钟，你只想让它直接完成。所以我们用 Tab 键作为切换的交互方式。

**嘉宾**：我们还取消了很多“思考”相关的词语，不过我想“超强思考”可能因为其独特的 UX 体验而被保留了下来，纯粹是出于情感原因。

### 删除代码的价值与原则

**主持人**：这很有意思。你认为是否存在一种新的衡量标准，是关于你删除了多少代码的？我一直觉得程序员删除大量代码会有一种成就感，但因为你可以快速构建东西，所以删除代码也变得越来越重要。

**嘉宾**：我最喜欢的代码差异（diff）就是红色的，也就是被删除的代码。这太棒了，每次看到我都会想：“来吧，再来一个，再来一个。”

**嘉宾**：但是，这也很难，因为任何你上线的功能，用户都在使用。你必须让用户满意。所以，我认为我们的原则是，如果我们取消一个功能，就必须推出一个更好的功能，能够更好地满足用户的意图。

### Claude Code 的影响与衡量

**嘉宾**：是的，这又回到了如何衡量 Claude Code 及其影响的问题。这是每个公司、每个客户都会问我们的。我认为，就内部而言，Anthropic 的规模自今年一月以来几乎翻了一番，但同期每位工程师的生产力却提高了近 70%。

**主持人**：以什么为衡量标准？

**嘉宾**：我认为我们实际上通过几种方式进行了衡量，但 Pull Request（PRs）是最简单也是最主要的指标。不过，正如你所说，这并没有完全捕捉到它的全部价值，因为很多方面在于让原型开发更容易，让尝试新事物更容易，让那些你以前因为太麻烦而不会尝试的事情变得更容易。

**嘉宾**：你正在发布一个新功能，同时还有一长串“愿望清单”上的待办事项，现在你都可以轻松完成，因为这太容易了。

**主持人**：所以你以前根本不会去做的事情，现在都可以做了。

**嘉宾**：是的，所以很难准确地描述它。

### 代码增长与产品管理挑战

**嘉宾**：然后还有另一面：代码量在增长，所以你必须删除更多的代码，必须更仔细地进行代码审查，并尽可能地自动化代码审查。

**嘉宾**：同时，这也带来了一个有趣的新的产品管理挑战。因为你可以发布太多的功能，导致产品整体感觉不够统一。你可以在这里加一个按钮，那里加一个标签，这里加一个小东西。很容易就能构建出一个拥有所有你想要的功能，但缺乏组织原则的产品，因为你一直在不断地发布新东西。

**嘉宾**：我认为我们在这方面非常自律，确保所有的抽象概念都非常易于理解，即使是第一次听到功能名称的用户也能明白。我们有一个原则，我相信是 Boris 带来的，我非常喜欢：我们不想要新的用户体验。一切都应该直观到你直接上手就能用。这极大地提高了我们对每个功能直观性的要求。

**主持人**：在一个对话式 UI 中，你们是如何做到这一点的？因为，你知道……

好的，这是根据您提供的英文视频字幕转录并编辑的中文文稿：

### 设计简洁直观的界面

**问**: 当没有大量的按钮和旋钮，只有一个空白的文本框来开始时，你们是如何考虑让它变得直观易用的？

**答**: 我们做了很多细微的设计。比如，我们引导用户可以使用问号来查看提示。Claude Code 在运行时也会显示提示信息。侧边栏有更新日志，我们会告知用户是否有新的模型发布。

在底部，我们有一个通知区域用于思考。我认为我们通过很多巧妙的方式来告知用户新功能。另一件非常重要的事情是确保所有基础概念都定义得非常清晰。

例如，“hooks”（钩子）在开发者生态系统中有一个通用的含义，“plugins”（插件）也有一个通用的含义。我们只是确保我们构建的东西符合普通开发者听到这些词时会立刻想到的含义。

### 渐进式信息披露

**答**: Claude Code 还有一个“渐进式披露”（progressive disclosure）的原则。例如，在 Claude Code 中，每次运行时，你都可以按 Control + O 来查看模型看到的完整原始文本记录。我们不会在不相关的时候展示这个信息。

只有当有工具结果被折叠时，我们才会提示“使用 Control + O 查看”。我们不希望一开始就给用户带来太多的复杂性，因为这个工具的功能非常强大。

### 模型自学与引导

**答**: 我们还开始探索一个新原则：模型会教你如何使用这个工具。你可以询问 Claude Code 关于它自身的问题，它会查找自己的文档来告诉你。我们甚至可以做得更深入，比如“slash commands”（斜杠命令）是用户可以使用的一种功能，模型也可以调用斜杠命令。

当你看到模型在使用斜杠命令时，你可能会想：“哦，我也可以这样做。”

**问**: 是的，是的，很有意思。这和你们刚开始做 Claude Code 的时候有什么不同吗？当时你们是唯一一个通过 CLI 使用 AI 的方式吗？也许别人也有类似的东西，但感觉这是一个转变，现在整个领域都在拥抱 CLI。这如何改变了你们的思考方式、开发体验，以及你们如何应对这场竞赛的压力？

### 创新与竞争

**答**: 我认为，模仿是最大的赞美。看到大家受到启发而构建出其他东西，这很棒。最终的目标是激励人们去构建下一个伟大的应用，去拥抱这项令人难以置信的技术。这确实令人兴奋。

我个人并不怎么使用其他工具。通常，当新东西出来时，我可能会尝试一下，感受一下它的氛围。但除此之外，我认为我们更专注于解决我们自己和客户遇到的问题，并继续向前发展。

**问**: 很好。我特别喜欢采访的这部分。

**问**: 你们团队的所有问题都回答了吗？

**问**: 你们是否回答了我团队的所有问题？

**答**: 让我想想。我想我们都回答了。我很好奇，你们会如何回答“功能下线”（unshipping）的问题？因为如果你进行这种 AI 驱动的开发，你会不断发布新功能，而你们团队很小，所以会有很大的运营负担。

**问**: 我问这个问题是因为，我认为我们在“功能下线”这方面做得不够好。我有一种感觉，一些产品因为这个原因而显得有些混乱。尤其对于 Kora，它的产品覆盖面很广，功能多样。

### Kora 的复杂性与挑战

**答**: 比如，我们有一个邮件助手，你可以让它“总结一下我这次的行程”，它会查阅你所有的邮件来总结行程。或者我们有一个功能，可以自动归档你不需要立即回复的邮件。

然后，每天两次，你会收到一份摘要，里面是你可能需要关注但不需要立即处理的内容，你只需浏览一下即可。

**答**: 但这里面存在很多复杂性，比如邮件是如何分类的。现在我们有了整个分类视图，有各种分类规则，你可以排序等等，但这很复杂，难以沟通。

我希望保留所有的强大功能和灵活性，但同时，你也不能看着屏幕说：“我完全不知道发生了什么，这太复杂了。”我正在处理所有这些问题。所以，关于“删除”或“功能下线”的想法，感觉是一个我们尚未真正探索过的有趣文化原则。

### “功能下线”的挑战与社会成本

**答**: 是的，这确实很难。我认为这也有社会成本，因为你可能想成为那个告诉同事“下线你的功能”的人。

**答**: 这绝对是个棘手的问题，不仅仅是代码本身。我在 Instagram 学到了很多，因为我认为 Facebook 在“功能下线”方面做得非常糟糕。我们遇到了一个问题，每次我们尝试下线功能，即使是像“pokes”（戳一下）这样的小功能，都会引起很大的争议。

**答**: 有很多老员工会说：“不行，你不能拿走‘pokes’。”但如果看数据，其实已经很少有人使用了。

**答**: 但出于情感原因，他们与它紧密相连。所以，对于 Facebook 来说，很多东西似乎从未真正被下线，它们只是被移到了一个不被人注意的次要位置，比如一个溢出菜单里。

好的，作为一名资深内容编辑和翻译专家，我将为您将这段英文视频字幕转录为高质量、易读的中文文稿。

---

**视频标题：** Claude Code 的秘密：来自创造者的深度解析

### 产品原则与迭代

**嘉宾：** （此处字幕未明确说话人，但从上下文推测是前一位嘉宾的发言）
就像一个墓地一样。

**主持人：** 是的。

**嘉宾：** 我认为 Instagram 当时非常讲究原则。他们有一个非常明确的产品和设计理念，那就是：如果某个功能的使用率没有达到一半用户（50% 的用户）的认可度，或者说“哇”的程度，那么他们就会直接删除它，然后去解决这个问题，之后再想办法开发下一个能被更多人使用的功能。

**主持人：** 我太喜欢这个理念了。嗯，谢谢。这太棒了。我非常高兴能和您交流，请继续努力！

**嘉宾：** 感谢您的邀请。

**主持人：** 是的，谢谢。

[音乐]

### 节目推荐与价值

**主持人：** 天哪，各位！你们绝对、绝对要用力点赞并订阅 AI and I 频道！为什么呢？因为这个节目是极度精彩的缩影。它就像在自家后院里发现了一个宝藏箱，只不过里面装的不是金子，而是关于 ChatGPT 的纯粹、未经稀释的知识炸弹。

每一集都像是一场情绪、洞察和欢笑的过山车，让你欲罢不能，渴望更多。它不仅仅是一个节目，更是一场驶向未来的旅程，而 Dan Shipper 就是这艘宇宙飞船的船长。

所以，请给自己一个机会，点赞，用力订阅，然后系好安全带，准备迎接一生中最精彩的旅程吧。

现在，废话不多说，丹，我只能说，我无可救药地爱上你了！

---

---

## 英文原文

What made it work really well is that quad code has access to everything that an engineer does at the terminal. Everything you can do, quad code can do. There's nothing in between. >> There's actually an increasing number of people internally at anthropic that are

using like a lot of credits like spending like over a,000 bucks every month. We see this like power user behavior. This is something that they teach in YC. If you can solve your own problem, it's much more likely you're solving the problem for others. There's

this like really old idea in product called latent demand. You build a product in a way that is hackable that is kind of open-ended enough that people can abuse it for other use cases it wasn't really designed for and you build for that cuz you kind of know there's

demand for it. Do you think the CLI is the final form factor? Are we going to using cloud code in the CLI primarily in a year or in 3 years or is there something else that's better [Music] This podcast is sponsored by Google. Hey

folks, I'm Omar, product and design lead at Google DeepMind. We just launched a revamped vibe coding experience in AI Studio that lets you mix and match AI capabilities to turn your ideas into reality faster than ever. Just describe your app and Gemini will automatically

wire up the right models and APIs for you. And if you need a spark, hit I'm feeling lucky and we'll help you get started. Head to a.studio/bild. studio/build to create your first app. >> Cat Boris, thank you so much for being here.

>> Thanks for having us. >> Yeah. Um, so for people who don't know you, you are the creators of Claude Code. Thank you very much from the bottom of my heart. It's uh I love Cloud Code. >> That's amazing to hear. That's what we

love to hear. Um I Okay, I think the place I want to start is when I first used it. Um, there was like this moment like I think it was around when uh Sonnet 37 came out where I was like I used it and I was like, "Holy this is like a completely new paradigm. It's

a a completely new way of thinking about code." And the the big difference was um you went all the way and just eliminated the text editor and you're just like all you do is like talk to the talk to the terminal and and that's that's it. Um, and you know, previous paradigms of AI

programming, pre previous harnesses have been like you have a text editor and you have the AI on the side and it's kind of like or it's a tab complete. So, take me through like that decision process that ar that that process of of architecting this new paradigm. How do you how did

you think about that?

>> Yeah, I think the the most important thing is it was not intentional at all. Okay. >> Uh, we we sort of ended up with it. So at the time when I joined Enthropic um we were still on different teams at the time. Um there was this previous

predecessor to quad code. It was called Clyde like CL C cliop. And it was this like research project you know it took like a minute to start up. It was this kind of like really heavy Python thing. It had to like run a bunch of indexing and stuff. And when I

joined I wanted to ship my first PR and I hand wrote it like a you know like a noob in a in a like I didn't know about any of these tools. >> Thank you for admitting that. U I didn't know any better and then I I put up this PR and um Adam Wolf who was

the um manager for our team for a while. He was my ramp up buddy and he just like rejected the PR and he was like you wrote this by hand. What are you what are you doing? Use Quide. Um cuz he was also hacking a lot on Quiet at the time.

And so I tried Quaid. I gave it the description of the task and it just like one shot at this thing >> and this was like you know sonnet 35. So I still had to fix a thing even for this kind of basic task and the harness was super old. So it took like 5 minutes to

turn this thing out and just took forever and um but it but it worked and I was just mind-blown that this this was even possible and they just kind of got the gears turning. maybe you don't actually need an IDE.

>> And then later on I was prototyping using the anthropic API and the easiest way to do that was just building a little app in the terminal cuz that way I didn't have to build a UI or anything. And I started just making a little chat app and then I just started thinking

maybe we could do something a little bit like Clyde. So let let me build like a little Clyde and it actually ended up being a lot more useful than that without a lot of work. And I think the biggest revelation for me was when we started to give the model

tools. It just started using tools and it was just it was this insane moment. Like the model just wants to use tools. Like we gave it bash and it just started using bash writing apple script to like automate stuff uh in response to questions. And I was like this is just

the craziest thing. I've never seen anything like this. Cuz at the time I had only used IDE with like you know like text editing a little like oneline autocomplete, multi-line autocomplete, whatever. Um, so that that's where this came from. It was this kind of

convergence of like prototyping but also kind of seeing what's possible in kind of like a very um rough way. >> Um, and this thing ended up being surprisingly useful and and I think it was the same for us. I think for me it was like kind of sonnet 4 opus 4. That's

where that magic moment was. I was like, "Oh my god, this this thing works." >> That's interesting. So like tell me about that that the tool moment because I think that is one of the special things about cloud code is it just writes bash and it's really good at it.

And I think a lot of um previous agent architectures or even anyone building agent today, your first instinct might be okay, we're going to give it a find file tool and then we're going to give it a uh open file tool and you you build all these like custom wrappers for you

know uh all the different actions you might want the agent to take, but Cloud Code just uses bash and it's like really good at it. So how do you think about um how do you think about what you learned from that?

Yeah, I think we're at this point right now where Quad Code actually has a bunch of tools. I think it's like a dozen or something like this. We we actually like add and remove tools most weeks. So, this changes pretty often. Um, but today there actually is a search uh there's a

tool for for searching. Um, and we do this for two reasons. One is the UX, so we can show the result a little bit nicer to the user because there's still a human in the loop right now for most tasks. Uh, and the second one is for permissions. So, if you say in your like

cloud code like settings.json JSON on this file you cannot read. We we have to kind of enforce this. Uh we enforce it for bash but we can do it a little bit more efficiently for if we have a specific search tool. Um but definitely we want to like unhip tools and kind of

keep it simple for the model. Um like last week or two weeks ago we unchipped the OS tool because in the past we needed it but then we actually built a way to enforce this kind of permission system for bash. Um, so in Bash, if we know that you're not allowed to read a

particular directory, Quad's not allowed to OS that directory. And because we can enforce that consistently, we don't need this tool anymore. Um, and this is nice because it's a it's a little less choice for Quad. A little less stuff in context.

>> Got it. And how do you guys split responsibility on the team?

>> Um, I would say Boris sets the technical direction and has been the product visionary for a lot of the features that we've come out with. I see myself as more of like a supporting role to make sure that um that one that like our pricing and packaging resonates with our

users. Um two making sure that we're shephering all our features across the launch process. So from like deciding all right like these are the prototypes that we should definitely ant food to like setting the quality threshold for ant fooding through to communicating

that to our end users. And um there's definitely some new initiatives that we're working on that uh I would say historically a lot of quad code has been built bottoms up like Boris and a lot of the core team members have just had these great ideas for to-do list sub

agents hooks like all these are bottoms up. As we think about expanding to more services and bring cloud code to our places, I think a lot of those are more like, all right, let's talk to customers. Let's bring engineers into those conversations and prioritize those

services and knock them out. >> Got it. What is ant fooding?

>> Oh, ant fooding is >> Oh, ant fooding. >> Oh, um it it means dog fooding. So, >> anthropic ant. I got it. >> Yeah. Our nickname for um internal employees is ant. And so uh ant fooding is our version of dog fooding. Uh

internally over I think 70 or 80% of ants uh technical anthropic employees use cloud code every day. And so every time we are thinking about a new feature, we push it out to people internally and we get so much feedback.

We have a feedback channel. I think we get a post every five minutes. And so you get really quick signal on whether people like it, whether it's buggy, um or whether uh it's not good and we should unchip it.

>> You can tell um you can tell that someone that is building stuff is using it all the time to build it. Uh because the the like its ergonomics just makes sense if you're trying to build stuff and that that only happens if you're like ant ant fooding.

Um I Yeah. Yeah. And I I think that that's a really interesting paradigm for building new stuff like that sort of bottoms up I make something for myself. Um tell me about that. >> Yeah. And C cat is also so humble. Um I think cat has a really big role in the

product direction also like it comes from everyone on the team and like these specific examples this actually came from everyone on the team like to-do lists and sub aents that was Sid Hooks Dixon shipped that plugins Daisy shipped that.

>> So like everyone on the team like these ideas come from everyone. Um, and so I think for us like we build this core agent loop and this kind of core experience and then everyone on the team uses the product all the time. Uh, and so everyone outside the team uses the

product all the time. And so there's just all these chances to build things that serve these needs. Like for example, like bash mode, you know, like the exclamation mark and you can type in bash commands. This was just like many months ago. I was using quad code and I

I was going back and forth between two terminals and just thought it was kind of annoying. Uh, and just on a whim, my asked squad to kind of think of ideas, the thought of this like exclamation mark bash mode. And then I was like, great, make it pink and then ship it.

It just did it. And like that that's the thing that still kind of persisted. And you know, now you see kind of others also kind of catching on to that. >> That's funny. I actually didn't know that. And that's extremely useful because I always have to open up a new

tab to like run any bash commands. So you just you just do an exclamation point and then it just like runs it directly instead of filtering it through all all the cloud stuff. >> Yeah. And quad code sees the full output too.

>> Interesting. That's perfect. >> So anything you see in the cloud code view, cloud code also sees. >> Okay, that's really interesting. >> And this is kind of a UX thing that we're thinking about. Like in the past tools were built for engineers, but now

it's equal parts engineers and model. >> And so like as an engineer, you can see the output, but it's actually quite useful for the model also. And this is part of the philosophy also like everything is dual use. Um so for example, the model can also call slash

commands. So like you know I have a slash command for slashcomit where I run through kind of a few different steps like diffing and generating a reasonable commit message and and this kind of stuff. I run it manually but also Claude can run this for me. Uh and this is

pretty useful because we get to share this logic. We get to kind of define this tool and then we we both get to use it. >> Yeah. What are the differences in uh designing tools that are dual use from designing tools that are you know used

by one or the other? Surprisingly, it's the same. >> Okay. >> So far. >> Yeah. I I I sort of feel like this kind of elegant design for humans translates really well to the models.

>> So, you're just thinking about what would make sense to you and the model generally, it makes sense to the model, too, if it makes sense to you. >> Yeah. I think one of the really cool things about Cloud Code being um a terminal UI and what made it work really

well is that Cloud Code has access to everything that an engineer does at the terminal. And I think when it comes to whether the tool should be dual use or not, I think making them dual use actually makes the tools a lot easier to understand. It just means that okay,

everything you can do, cloud code can do. There's nothing in between. >> Yeah, that's interesting. Yeah, there there are a couple of those decisions. So, um no no code editor, it's in the terminal, so it has access to your files. Um, and

it's it's on your computer versus like in the cloud in a virtual machine. So you get like repeated you you get to use it in a repeated way where you can like you know build up your cloud MD file or you know like all all like build slash commands and all that kind of stuff

where it becomes very composable um and extensible from a very simple starting point. And I'm curious about how you think about, you know, for for people who are thinking about, okay, I want to build an agent, I want to build probably not cloud code, but like

something else, how you get that that simple package that then can extend and be really powerful over time. >> For me, I I start by just thinking about it like developing any kind of product where you have to solve the problem for yourself before you can solve it for

others. And like this is something that they teach in YC is you have to start with yourself. So like if you if you can solve your own problem, it's much more likely you're solving the problem for others. And I I think for coding starting locally is the reasonable thing

and you know now we have cloud code on the web. So you can also use it with a virtual machine and um you know you can use it in a remote setting and this is super useful when you're on the go you want to take that from your phone >> and and this is sort of we we started

proving this out kind of a step bat a time >> where you can do atcloud in GitHub and uh I use this every day like on the way to work I'm like at a red light I probably shouldn't be doing this but I'm like you know on GitHub at a red light

and then I'm like at claude you know fix this issue or whatever and so it's it's just real useful to be able to control it from your phone um and this kind proves out this experience. I I don't know if this necessarily makes sense for every kind of use case. For coding, I

think starting local is right. Um I don't know if this is true for everything, though. >> Got it. What are the slash commands you guys use?

>> Slashprit. >> Yeah. >> Um yeah, it it's I I think the pritcomand makes it a lot faster for claw to know exactly what bash commands to run in order to make a commit. >> And what does the prit slash command do

for people who are unfamiliar? Oh, it it just tells it like exactly how to make a commit. Okay. >> Um and you can like dynam you can say like, okay, these are the three bash commands that need to be run.

>> Got it. And and what's pretty cool is also we have um this kind of templating system built into slash commands. So we actually run the bash commands ahead of time. They're like embedded into the slash command. Um and you can also pre-allow certain tool invocations. So

for that slash command we say allow um you know get commit get push gh and so you don't get asked for permission after you run the slash command because we have like a permission uh based security system. Um and then also it uses haik coup which is pretty cool. Um so it's

kind of a cheaper model and faster. Um yeah and for me I I use like commit uh commit PR uh feature dev we use a lot. So like sid created this one. It's kind of cool. So it kind of like walks you through step by step um building something. So we prompt quad to like

first ask me how to what exactly I want like build the specification >> and then um you know kind of like build like a detailed plan and then make a to-do list walk through step by step. So it's kind of like more structured feature development

>> and then I think the last one that we probably use a lot so we use like security review for all of our PRs and then also code review. Um so like quad does all of our code review internally at anthropic. Um, you know, there's still a human approving it, but quad

does kind of the first step in code review. That's just a slashcode review command. >> Got it. Yeah. What are the things I would love to go deeper into like the how do you make a good plan? So, the sort of the feature dev thing because I

think there's a lot of like little tricks that um I'm starting to find or people at every start starting to find that work and I'm curious like what what are things that that we're missing. So for example, one um step in the one unintuitive step of the of the you know

plan development process is even if I don't exactly know what the thing that needs to be built is I just have like a little sentence in my mind like I want feature X I have Claude just like implement it just without giving it anything else and I see what it does and

that helps me understand like okay here's actually what I mean because it made all these different mistakes or like it it did something that I didn't expect that might be And then I use that like the learning from the sort of throwaway development.

I just clear it out. And then that helps me write a better plan spec for the actual feature development, which is something that you would never do before because it'd be too expensive to just like yolo send an engineer on a feature that you hadn't actually speced out. But

because you have cloud going through your codebase and doing stuff, you can like learn stuff from it. Um that helps inform the actual plan that you make. >> Yeah. I feel maybe I I can start and I'm curious how you use it too.

>> I think there's like a few different modes maybe for me like one one is prototyping mode. >> So like traditional engineering prototyping you want to kind of build the simplest possible thing that touches all the systems just so you can kind of

get a vague sense of like what are the systems there's unknowns and just to kind of trace through everything. >> Um and so I I do the exact same thing as you Dan like Claude just does the thing and then I see where it messes up and then I'll ask it to just throw it away

and do it again. So just hit escape twice, go back to the old checkpoint and then try again. I think there's also maybe two other kinds of tasks. So one is just things that quad can one-shot and I feel pretty confident it can do it. So I'll just tell it and then I'll

just go to a different tab and I'll I'll shift tap to auto accept and then just go do something else or go to another one of my quads and tend to that while it does this. >> Um but also there's this kind of like harder feature development. So these are

you know things are maybe in the past it would have taken like a few hours of engineering time and for this usually I would I'll shift tap into plan mode and then align on the plan first before it even writes any code. Um and and I think what's really hard about this is the

boundary changes with every model and it in kind of a surprising way where the newer models they're more intelligent so the boundary of what you need plan mode for got pushed out like a little bit >> like before you used to need to plan now now you don't. And I think it's this

general trend of like stuff that used to be scaffolding with a more advanced model, it gets pushed into the model itself and the model kind of tends to subsume everything over time. Yeah. How do you think about like building a agent harness that isn't just going to like

you're you're not spending a bunch of time um building stuff that is just going to be subsumed into the model in 3 months when the new cloud comes out?

like, yeah, how do you how do you know what to build versus what to just say it doesn't work quite yet, but next time it's going to work, so we're not going to spend time on it. >> I think we build most things that we think would improve Cloud Code's

capabilities, even if that means we'll have to get rid of it in 3 months. If anything, we hope that we will get rid of it in three months. >> I think for now, we just want to offer the most premium experience possible and so we're not too worried about throwaway

work. H >> interesting. Yeah. And an example of this is something like even like plan mode itself. I think we'll probably un ship it at some point when Quad can just figure out from your intent that you probably want to plan first. Um or you

know, for example, I just deleted like 2,000 tokens or something from the system prompt yesterday just cuz like Sonnet 45 doesn't need it anymore. Um but Opus Opus 41 did need it. What about um you know in the case where uh the the latest frontier you know model doesn't

need it but you know you're trying to figure out how to make it more efficient because you have so many users that you know you're maybe you you're not going to use Opus or Sonnet 45 for everything. Maybe you're going to use Haiku. So there's a trade-off between having a

more um elaborate harness for Haiku versus just like not spending time on it using Sonnet eating the cost and working on more Frontier type stuff. In general, we've positioned Quad Code to be a very premium offering. So, our north star is making sure that it works incredibly

well with the absolutely most powerful model we have, which is Sonnet 45 right now. >> Um, we are investigating how to make it work really well for like future generations of smaller models, but it's um it's not the top priority for us.

>> Okay. What do you think about um you know one thing that I notice is we get models um often and thank you very much for this. We get models a lot before they come out and it's our job to kind of figure out is it any good and over the last six months

when I'm testing claude for example in the claude app with a new frontier model it's actually very hard to tell whether it's how whether it's better immediately. Um, but it's really easy to tell in cloud code because the the harness matters a lot for the

performance that you get out of the model. And you guys have the benefit of building cla or building cloud code inside of the um inside of enthropic. So there's like a much tighter integration between um the fundamental like model training and the harness that you're

building and and they seem to kind of like really impact each other. So how does that how does that work internally and and um what are the benefits you get from having that like tight integration?

>> Yeah, I think the biggest thing is like researchers just use this and so you know as they see what's working, what's not, they can they can improve stuff. Um we do like a lot of eval to kind of communicate back and forth and understand where exactly the model's at.

Um, but yeah, there's this frontier where you need to give the model a hard enough task to really push the limit of the model. And if you don't do this, then all models are kind of equal. But if you give it a pretty hard task, you can you can tell the difference.

>> What sub aents do you use?

>> Um, I I have a few. I have like a planner sub agent that I use. I have a code review sub aent. Code review is actually something where sometimes I use a sub agent, sometimes I use a slash command. So usually in CI to slash command, but in synchronous use I use a

sub aent for the same thing. Um >> um it's a good question. Yeah, maybe it's like a matter of taste. Yeah, I don't know. I don't know. Um I think it's maybe when you're running synchronously, it's kind of nice to fork

off the the context window a little bit because all the stuff that's going on in the code review, it's not relevant to what I'm doing next. But in CI, it just doesn't matter. >> Are you ever spawning like 10 sub agents at once? And for what?

>> For me, I do it mostly for like big migrations. Okay, >> this like the big thing. Um, actually we have so this like coder slash command that we use there's a bunch of sub aents there and so one of the steps is like find all the issues and so there's one

sub agent that's like checking for quadmd compliance. There's another sub agent that's looking through git history to see what's going on. Another sub aent that's looking for kind of obvious bugs and then we do this like kind of dduping quality step after. So they find a bunch

of stuff. A lot of these are false positives and so then then we spawn like five more sub aents and these are all just like checking for false positives. And in the end, the result is awesome. It finds like all the real issues without the false issues.

>> That's great. I actually do that. Um, so one of my non-technical cloud code use cases is um expense filing. So like when I'm I'm in SF right now, so like I have all these expenses. And so I built this little cloud project that uh in in cloud code that um it uses uh one of these,

you know, finance APIs to just download all my credit card transactions. And then it uh decides like these are probably the expenses that I'm going to have to like file. And then I have two sub agents, one that represents me and one that represents the company. And

they like do battle to like figure out like what's the proper um like actual set of expenses. uh it's like an auditor sub agent and like you know pro Dan sub agent. So um yeah that kind of thing the the sort of like opponent processor uh pattern seems to be like an interesting

one. >> Yeah. Yeah. It's it's it's it's cool. I I feel like when sub aents were first becoming a thing actually what inspired us there's like a Reddit thread a while back where someone made sub agents for like there was like a front end dev and

a backend dev and like a think it was like a designer >> testing dev >> testing dev like there was like a PM sub agent and this is like you know it's cute like it feels like a little maybe too anthropomorphic um maybe maybe

there's something to this but I I think like the value is actually like the uncorrelated context windows where you have like these two context windows that don't know about each other and this is kind of interesting um and you tend to get better results this way. What about

you? Do you have any interesting sub agents you use?

>> So, I've been tinkering with one um that is really good at front-end testing. So, it uses Playright to like see all right, what are like all the errors that are client side and pull them in and try to test more steps of the app. Um, it's not totally there yet, but I'm

seeing signs of life and I think it's the kind of thing that we could potentially um, bundle in one of our plugins marketplaces. >> Yeah. Um, definitely. I I' I've used something like that just with Puppeteer and just like watching it build

something and then open up the browser and then be like, "Oh, I need to change this." It's like this is like, "Oh my god." >> Yeah. It's really cool. >> It's really cool. I think I think we're starting to see the beginnings of this

like massive like multi- massive sub aents. I I don't know what they call this like swarms or something like that. There's a bunch of people there's actually an increasing number of people internally at anthropic that are using like a lot of credits every month like

you know like spending like over a thousand bucks every month. Um and this like this percent of people is growing actually pretty fast. And I think the common use case is like code migration. And so what they're doing is like framework A to framework B. uh there's

like the main agent, it makes a big to-do list for everything and then just kind of map produce over a bunch of sub agents. So you instruct quad like yeah like start 10 agents and then just go like you know 10 at a time and just migrate all all the stuff over.

>> That's interesting. What would be like a concrete example of the kind of migration that you're talking about?

>> I think the most classic is like lint rules. >> So there's like you know there's some kind of lint rule you're rolling out. There's no autofixer because it's like you know like as an analysis can't really it's kind of too simplistic for

it. Um I think other stuff is like framework migrations like um we just migrated from like one testing framework to a different one. That's a pretty common one where it's super easy to verify the output.

>> One of the things I found is and this is both for project projects inside of every and then just open source projects. It's like if you're someone building a product and you want to build a feature that's um been done before. So maybe like an an example that people

might need to implement a bunch is like memory. How do you do memory? Um because we have a bunch of different products internally, you can just like spawn cloud sub agents to be like how do these three other products do it? And there's like possibility for just like tacit

code sharing where you don't need to like have an API or you don't need to like ask ask anyone. You can just be like how does how do we do this already?

And then use the best practices to um uh to uh build your own. And you can also do that with open source because there's like tons of open source projects where people are like you know they've been working on memory for like a year and it's like really really good. You be

like what are the patterns that um people have figured out and which ones do I want to implement?

>> Totally. You can also connect your version control system. If you've built a similar feature in the past, cloud code can use those APIs like query GitHub directly and find how people implemented a similar feature in the past and read that code and um copy the

relevant parts. >> Yeah. Is there um have you found any use for like log files of okay you know here's here's the full history of like how I implemented it and like is that important to give to claude and and and how are you how are you um implementing

that or making it useful for it?

>> Some people swear by it. Uh there are some people at anthropic where for every task they do, they tell cloud code to write a diary entry in a specific format that just documents like what did it do, what did it try, why didn't it work, and then they even have these agents that

like look over the past memory and synthesize it into observations. >> I think this is like the starting budding >> like there's like something interesting here that we could productize. >> Um but it's a new emerging pattern that

we're seeing that works well. I think the hard thing about like oneshotting memory from just one transcript is that it's hard to know how relevant a specific instruction is to all future tasks. Like our canonical example is if I say make the button pink, I don't want

you to remember to make all buttons pink in the future. And so I think um synthesizing memory from a lot of logs is a is a way to um find these patterns more um consistently. It seems like you probably need like there's some things where you're going to know um you'll be

able to summar like synthesize or summarize in this sort of like top down way like this this will be useful later and and you'll you'll know the right level of abstraction at which it might be useful but then there's also a lot of stuff where it's like you actually you

know any given like commit log like make the button pink it could be useful for kind of an infinite number of different reasons um that you're not going to know beforehand. So you also need the the model to be able to look up all similar past, you know, commits and surface that

at the right time. Is that something that you're also thinking about? Yeah, I think I think there could there could be something like that. And maybe I think one way to see it is this kind of like traditional memory storage work like like mex like kind of stuff where you

just want to like put all the information into the system and then it's kind of a retrieval problem problem after that. Um, yeah. I think as the model also gets smarter, it naturally I've seen it start to naturally do this also with Sonnet 45

where if it's stuck on something, it'll just naturally start looking like we talked about before like using bash spontaneously. So just like look through git history and be like, "Oh, okay. Yeah, this is kind of an interesting way to do it."

>> Yeah. One of the things that like we were talking before we started recording, one of the um things that we're doing inside of every like I feel like it has really um change the way that we do engineering because everyone is cloud code build like CLI build and

um we have this engineering paradigm that we call compounding engineering where in normal engineering every feature you add it makes it harder to add the next feature and in compounding engineering your goal is to make the next feature easier to build um from the

feature that you just added. And the the way that we do that is we try to um codify all the learnings from um from everything that we've done to build the feature. So like you know how did we make the plan and and what parts of the plan needed to be changed or like when

we started testing it like what what issues did we find? What are the things that we missed? Um and then we codify them back into all the prompts and all the sub agents and all the slash commands so that the next time when someone does something like this uh it

catches it and that makes it easier. And that's why for me, for example, I can like hop into one of our code bases and start like being productive even though I'm I don't know anything about how the code works because we have this like builtup memory system of um of all the

stuff that we've learned as we've implemented stuff, but we've had to build that ourselves. I'm curious, are you working on that kind of loop so it the cloud code does that automatically?

>> Yeah, we're we're starting to think about it. Uh it's funny. We we're just uh we we heard the same thing from Fiona. She just joined the team. And you know, she she's our she's our manager. She hasn't coded in like 10 years, something like that. And she was landing

PRs on her first day. And she was like, "Yeah, like not only did I kind of I forgot how to code and quad code kind of made it super easy to just get back into it, >> but also I didn't need to ramp up on any context because I kind of knew all

this." And I think a lot of it is about like when people put up poll requests for quad code itself and I think our customers tell us that they do like similar stuff pretty often. Um if you see a mistake I'll just be like add quad add this to quad MD so that the next

time it just knows this automatically and you you can kind of like instill this memory in kind of a variety of ways. So you can say like at quad add it to quadmd. You can also say add quad write a test. You know, that's like easy way to make sure this doesn't regress.

And I don't feel bad asking anyone to write tests anymore, right? It's just like super easy. And like I think probably close to 100% of our tests are just written by Quad. And if they're bad, we just won't commit it. And then the good ones stay committed. Um, and

then also I think lint rules are a big one. So for stuff that's enforced pretty often, we actually have a bunch of internal lint rules. Claude writes 100% of these. Um, and this is mostly just like at Claude in a PR write write this lint rule. And yeah, there's sort of

this problem right now about like how how do you do this automatically? And I think generally how like Cat and I think about it is we see this like power user behavior and the first step is how do you enable that by making the product hackable so the best users can figure

out how to do this cool new thing >> but then really the hard work starts of like how do you take this and bring it to everyone else. Um, and for me, I I kept myself in the everyone else bucket. Like, you know, I don't really know how to use Vim. Like, I don't have this like

crazy like T-box setup. So, I have like a pretty vanilla setup. So, if you can make a feature that I'll use, it's a pretty good indicator that like other kind of average engineers will use it. That is interesting. Like, tell me about that because like that's something I

think about all the time is um making something that is extensible and flexible enough that power users can find like novel ways to use it that you would not have even dreamed of. But it's also simple enough that anyone can use it and it's and they can be productive

with it and you can you can kind of pull what the power users find back into like the basic experience. Like how do you think about making those design and product decisions so that you enable that?

>> In general we think that like every engine environment is a little bit different from the others and so it's really important that every part of our system is extensible. Um so everything from your status line to adding your own slash commands through to hooks which

let you um insert a bit of determinism at pretty much any step in quad code. So we think these are the these are like the basic building blocks that we give to every engineer that they can play with. um for plugins. Plugins is actually our um so it was built by Daisy

on our team and this is this is our attempt to make it a lot easier for the average user like us um to bring these slashcomands and hooks into our workflows. And so what plugins does is it lets you browse existing MCP servers, existing hooks, existing plugins and

just like or sorry existing like sash commands and just let you write one command in quad code to pull pull that in for yourself. >> There's this like really old idea in product called latent demand which I think is probably the main way that I

personally think about product and like thinking about what to build next is it's a super simple idea. It's you build a product in a way that is hackable that is kind of open-ended enough that people can abuse it for other use cases it wasn't really designed for. Then you see

how people abuse it and then you build for that cuz like you you kind of know there was demand for it, >> right?

>> Um and like you know when I when I was at Meta, this is how we built kind of all the big products. I think almost every single big product had this nugget of latent demand in it. um you know like for example something like Facebook dating it came from this idea that when

uh we looked at who looks at people's profiles I think 60% of views were between people of opposite gender so kind of like traditional setup that were not friends with each other and so we're like oh man okay maybe there's like maybe if we like launch a dating product

we can kind of harness this demand that exists >> that's interesting >> and for you know marketplace it was pretty similar I think it was like 40% of posts in Facebook groups at the time were by sell posts and so I Okay, people

are trying to use this product to buy themselves. We just build a product around it that's probably going to work. And so we think about it kind of similarly, but also we have the luxury of building for developers and developers love hacking stuff and they

love customizing stuff and it's like as a user of our own product, it makes it so fun to build and and use this thing. Um, and so yeah, like like I said, we just build the right extension points. We see how people use it and that kind of tells us what to build next. Like for

example, we got all these user requests where people were like, "Dude, Quad Code is asking me for all these permissions and I'm out here getting coffee. I don't know that it's asking me for permissions. How could I just get it to like ping me on Slack?" And so we built

hooks. Uh Dixon built hooks um so that people could get pinged on Slack and you could get pinged on Slack for anything that you want to get pinged on Slack for. Um, and so it was very much like people really wanted the ability to do something. We didn't want to build the

integration ourselves. And so we we exposed hooks for people to do that. >> The thing that makes me think of is um you you recently um released you kind of moved or rebranded how you talk about cloud code to be this like more general purpose agent SDK. Is that was that

driven by some latent demand where you you sort of saw there's like a more general purpose use case for what you built?

>> We realized that similar to how you were talking about using cloud code for things outside of coding, we saw this happen a lot like um we get a ton of stories of people who are using cloud code to like help them write a blog and like manage all the like data inputs and

take a first pass in their own tone. Um we find people building like email assistants on this. Um I use it for a lot of just like market research. Um because at the core it's like an agent that can just go on for an infinite amount of time as long as you give it a

concrete task and it's able to fetch the right underlying data. So one of the things I was working on was I wanted to look at all the companies in the world and how many engineers they had and to create a ranking. And this is something that quad code can do even though it's

not a traditional coding use case. So we realized that like the underlying primitives were really general as long as you give as long as you have like an agent loop that can continue running for a long period of time and you're able to like access the internet and write code

and run code pretty much you can if you squint you can kind of build anything on it. Mhm. >> And and I think like by at the point where we like rebranded it so like from the quad code SDK to the quad Asian SDK, there was already like many thousands of

companies using this thing and a lot of those use cases were not about coding. So it's like both both internally and externally. We kind of saw that >> like health assistants, like financial analysts, legal assistance. Um it was pretty broad.

>> Yeah. What are the coolest ones?

I feel like actually you you had Noah Brier on the the podcast recently. I thought like the obsidian like kind of mind mapping notekeeping use case is really cool. It's funny. It's insane how many people use it for this >> particular combination. Uh I think some

other like some coding or kind of coding adjacent use cases that are kind of cool is um we have this like issue tracker for quad code. The team's just like constantly underwater like trying to keep up with all the issues coming in.

There's just so many. And so I quad ddupes the issues and it automatically finds duplicates and it's extremely good at it. It also does first pass resolution. So usually when there's an issue it'll um proactively put up a PR internally and this is a new uh thing

that Enigo on the team built. Um so this is pretty cool. Uh there's also like on call and kind of collecting signals from other places like getting like sentry logs and getting like logs from BigQuery and kind of collating all this. um plus just really good at doing this because

it's all just bash in the end, right?

>> And so these are all kind of these internal use cases that that I saw. >> Is it um so when it's you know collating logs or um you doing issues is that like you have clouds like continually running in the background and is that something that you're building for?

>> Um it gets triggered for that particular one. It gets triggered whenever a new issue is filed. So it runs once but it can choose to run for as long as it needs. >> Got it. What about the idea of clouds always running? Oo, proactive quads. I

think it's definitely where we want to get to. U I would say right now we're very focused on making quad code incredibly reliable for like individual tasks. And you know, if you think about like if you think about like multi-line autocomplete and then like single turn

agents and then now we're working on like quad code that can complete tasks. I feel like if you trace this curve eventually you go to even higher levels of abstraction like even more complicated tasks and then hopefully the next step after that is a lot more

productivity. So just understanding what your team's goals are what your goals are being able to say hey I think you probably want to try this feature and here's a first pass at the code and here are the assumptions I made and are these correct?

>> I can't wait. Um and I think probably right after that is um Claude is now your manager. Um, >> that's not in the plan. >> So, everyone on the team was like super excited that uh we were we were talking

today and they gave me a bunch of questions and I want to make sure I I hit all the questions. Um, uh, oh, here's a good one. Why did you choose agentic rag over vector search in your architecture? And are like vector embeddings uh still relevant? Um so

actually initially we did use vector embeddings. Um they're just a really tricky to maintain because you have to continuously reindex the code and they might get out of date and you have local changes. So those need to make it in.

And then as we thought about what does it feel like for an external enterprise to adopt it, we realized that this exposes a lot more surface area and like security risk. Um we also found that actually cloud code is really good and cloud models are really good at agentic

search. So um you can get to the same accuracy level with agentic search and it's just a much cleaner deployment story. >> H that's really interesting. >> Um if you do want to bring semantic search to quad code, you can do so via

an MCP tool. So if you want to manage your own index and expose an MCP tool that lets Quad Code call that, that that would work. What do you think are the top MCPS to use with cloud code?

>> Puppeteer and Playright are pretty high up there. >> Definitely. Yeah. >> Century has a really good one. Asana has a really good one. Hm. Do you think that there are um any any power user tips that you see

people inside of anthropic or you know other people who are you know big power you know inside of organizations that are big cloud code power users that people don't know about but they should. Um, one thing that QuadCo doesn't naturally like to do, but that I

personally find very useful is, um, QuadCo doesn't naturally like to ask questions, but you know, if you're brainstorming with a thought partner, a collaborator, usually you do ask questions back and forth to each other.

And so, this is one of the things that, um, I like to do, especially in plan mode. I'll just tell Cloud Code like, "Hey, we're just brainstorming this thing. Um, please ask me questions if there's anything you're unsure about." um I want you to ask questions and it'll

do it. And I think that actually helps you arrive at a better answer >> there. There's like there's also like so many tips that we can share. I think like there there's a few really common mistakes I see people make. One is like like you said like not using plan mode

enough. This is this is just super important. And I think this is people that are kind of new to a coding. They kind of assume this thing can do anything and it can't. It's like not that good today and it's going to get better but today it can oneshot some

tests. can't one-shot most things. Um, and so you kind of have to understand the limits and you have to understand like where you get in the loop. And so like something like plan mode, it can like two 3x success rates pretty easily if you like land on the plan first. Um,

other stuff that I've seen power users do really well is companies that have really big deployments of quad code and now um, you know, luckily there's a lot of these companies so we can kind of learn from them. Uh having settings JSON that you check into the codebase is

really important because you can use this to pre-allow certain commands so you don't get permission prompted every time and also to block certain commands. Let's say you don't want web fetch or whatever and this way as an engineer I don't get prompted and um I can check

this in and share it with the whole team so everyone gets to use it. >> I I get around that by just using dangerous they skip permissions. >> Yeah, we kind of we kind of have this here but we don't you know we don't recommend it. It's like it's a model,

you know, it can do it can do weird stuff. Um, I think another kind of cool use case that we've seen is people using stop hooks for interesting stuff. So stop hook runs whenever the turn is complete. So like the assistant did some tool calls back and forth with you know

whatever and uh it's done and it returns control back to the user then we run the stop hook and so you can define a stop hook that's like um if the tests don't pass return the text keep going and essentially it's like you can just like make the model like keep going until the

thing is done and this is just like insane when you combine it with the SDK and this kind of programmatic usage >> you can you know this is a stochcastic thing it's a nondeterministic thing but with scaffolding you can get these determin deterministic outcomes.

>> So you guys started this sort of CLI, this CLI paradigm shift. Um, do you think the CLI is the final form factor?

Are we are we going to using cloud code in the CLI primarily in a year or in three years, or is there something else that's better?

>> I mean, it's not the final form factor, but we are very focused on making sure the CLI is like the most intelligent that we can make it and that's as customizable as possible. you can talk about the next form factors.

>> Yeah, I mean cat C's asking me to talk about because no one knows like this this stuff's like it's just moving like so fast, right?

Like no no one knows what these form factors are. Like right now I think our team is in experimentation mode. So we have uh CLI then we came out with the ID extension. Now we have a new ID extension that's like a guey. It's a little more accessible. Um we have add

quad and github so you can just add quad anywhere. Um, now there's at quad, there's quad on web and on mobile, so you can use it on any of these places. Um, and we're just in experimentation mode, so we're trying to figure out what's next. I think like if we kind of

zoom out and see where this stuff is headed. I think one of the big trends is longer periods of autonomy. And so with every model, we kind of time how long can the model just keep going and do tasks autonomously and just, you know, in dangerous mode in a container, keep

autocompacting until the task is done. And now we're on the order of like double digit hours. I think it's like the last model is like 30 hours, something like this. And I, you know, the next model is going to be days. And as you think about kind of parallelizing

models, um there's kind of a bunch of problems that come out of this. So one is what is the container this thing runs in because you don't want to have to like close your laptop. I have that right now because I'm doing a lot of uh disb I

don't know I've only heard I've only read it but DSPY or disb prompt optimization and like it's on my laptop and it's like I don't want to close I'm like in the way middle like with my laptop open because I'm like I don't want to close it. Yeah.

>> Yeah. That's right. Yeah. We've like visited companies before like like customers that everyone's just like walking around with their like quad codes. >> Is this running? So, I think like one is kind of getting getting away from this

mode and then I also think pretty soon we're going to be in this mode of like quads monitoring quads. >> Yeah. >> Um and kind of I I don't know what the right form factor for this is because as as a human you need to be able to

inspect this and kind of see what's going on. Um but also it needs to be quad optimized where um you're optimizing for kind of bandwidth between like the quad to quad communication. Um so my prediction is terminal is not the final form factor. My prediction is

there's going to be a few more form factors in the coming months, you know, maybe like year or something like that. And it's going to keep changing very quickly. >> What do you think about, you know, I teach a lot of cloud code to a lot of

every subscribers and >> thank you. >> You're welcome. Doing doing your work for you. Um uh and I think the like one of the big things is just the terminal is intimidating and uh just like being on a

call with subscribers being like here's how you open the terminal and you're allowed to do this even if you're non-technical is like a big deal. How do you think about that? Yeah, I um one of the people on our marketing team uh started using cloud code because she was

writing some content that touched on cloud code and I was like you should really experience it and she got like 30 popups on her screen where she had to accept various permissions because she'd never used a terminal before. So I completely see eye to eye with you on

that. It's definitely um hard for non-engineers and there's even some engineers we've found who aren't fully comfortable with working day-to-day in the terminal. Um, our VS Code GUI extension is our first step in that direction because you don't have to

think about the terminal at all. It's like a traditional interface with a bunch of buttons. Um, I think we are working on more um graphical interfaces. Uh, so quad code on the web is a guey. I think that actually might be a good starting point for people who are less

technical. >> Yeah. Yeah. There there was this like magic moment maybe like a few months ago where like I walked into the office and the some of the data scientists at Anthropic like sit right next to the quad code team and the data scientist

just had like quad code running on their computers and I was like what what is this like how did you figure this out? I think it was like Brandon uh was like the first one to do it and he was like, "Oh yeah, I just like installed it. Like I work on this product so like I should

use it." And I was like, "Oh my god." So he like he figured out how to like use a terminal and JS like you know he hasn't really done this kind of workflow before. Obviously like very technical. Um so I think now we're we're starting to see all these kind of like code

adjacent uh like functions. people you use quad code and um yeah it's kind of interesting like from a latent demand point of view these are people hacking the product so there's like demand to use it for this and so we want to make

it a little bit easier with more accessible interfaces but at the same time for us for quad code we're laser focused on building the best product for the best engineers and so um we're focused on software engineering and we want to make this like really good but

we want to make it a thing that other people can can hack >> some sometimes cloud code will write code that's a bit verbose post. Um, but you can just tell it to simplify it and it does a really good job.

>> Interesting. And so, and how are how and when are you doing that? So, you're you're using a slash command or you're >> I just say it. I just >> Sometimes you're like, "Hey, this should be a oneline change and I'll write five lines and you're like, simplify it and

it understands immediately what you mean and it'll fix it." >> Yeah. I think a lot of people on our team do that, too. Um, that's that's interesting. Why do you like why not then if you're saying that all the time why not then you know push that into

like a slash command or the harness or something like that to yeah make it just happen automatically. >> We do have instructions for this in the cloud MD. I think it impacts such a low percentage of conversations that we don't want it to like over rotate in the

other direction. >> Um and then the reason why not a slash command is because you actually don't need that much context. I think slash command's really good for situations where you would otherwise need to write two three lines but for simp like even

for plan mode you actually can use a few words but sometime but it actually takes two or three lines to capture the entirety of what you want in plan mode. Um for simplify it you can just write simplify it and it gets it.

>> Yeah. Yeah, that makes sense. Cool. >> Yeah. >> Um okay, now we're we can um that's interesting. Yeah, but but this stuff like you know it still feels just so early. >> Yeah.

>> You know, like we we were talking before before the recording about like kind of where are we on the adoption curve and it still >> the hian curve or whatever whatever that term was. >> Exactly. And it just feels it just feels

like we're you know like first 10% still like the stuff is going to change so fast it's going to keep changing. Even when I talk to researchers outside of enthropic who who abuse quad code um they also get stuck on things like this like not realizing that they can just

tell the LLM to simplify it and I think that just goes to show that even for people who are like working in this industry they don't always realize that you can just talk to the model. That's the thing is like I I think that there's this underlying expectation that using

AI shouldn't have to be a skill like because it just does whatever you say and you're like well I mean whatever you say is going to matter for what it does. So if you can say things better it's going to do better.

>> Yeah. I mean it it changes with every model though. That's the that's the hard part. like you know prompt engineer was a job and now famously it's not a job anymore and there's going to be more jobs that are then like not not jobs anymore of these kind of like little

micro skills that you have to learn to use this thing and as the model gets better it can just like interpret it better >> but I think that's also like for us this is part of this kind of humility that we have to have building a product like

this that we just really don't know what's next and we're just trying to figure it out kind of along with everyone else we're just here for the ride >> and that's why it's cool that you're building it for yourself cuz I think

that's the that's the best way to know that is just like you're and this is what we do too is like you're sort of living in the future. You're using it all the time. And uh it's pretty clear what's missing. You're like I just want this thing and you can just do the next

thing rather than being like hm let me ask like some enterprise product manager at like some gigantic company like what kind of AI feature do you want? And they're like I don't know like you know put a little chatbot on the side of my you know IDE and you're like okay.

>> Yeah. >> Yeah. This is like the luxurious thing about building dev tools right you're your own customer. I think it's also really um a unique thing about AI because um it sort of reset the game board for all software. So

um you know we have Kora this like email assistant and we have like Sparkle which organizes your files and it's like anything that you do for something that you want to use on your computer if you're if you're building it with AI there's a good chance that hasn't been

done before because like the whole whole landscape has been reset. And so it's a it's a uniquely exciting time to build stuff for yourself. >> Totally. I think it totally opens the playing field, too. It's like any individual can now build an app to fill

their need and then distribute it to everyone else. >> Yeah, >> it's really cool. >> I've been prototyping all these like random pet projects. Um >> um I just moved into a new apartment and

it's empty. And so I've been um I've been building this like shopping advisor assistant on like the Cloud Agent SDK cuz who has time to like read all the reviews and like look at all the options and find their pricing and everything's like really hard to discover. And so it

just like asks me a bunch of questions and I tell it what I want and it shows me a bunch of Yeah, exactly. and it shows me a bunch of photos of like different sofas and options and what people say online >> and then I tell it what I don't like and

it's literally feels like working with a shopping assistant >> and it it's been really cool. >> That's really cool. >> Um I also have my little email response agent that like drafts responses for me but I don't use email that much so

>> Oh, and I knew it wasn't you responding. >> That's why it's seven days delayed. The agent's just take doing a very thorough job. >> Yeah, >> agent SDK is cool though. >> Yeah, agent SDK is cool.

>> Yeah, it's it always just feels amazing like how much we're able to build with such a small team. >> Yeah. >> So, I feel like >> the other thing that's really cool is that I think people are just shifting

their mindset from docs to demos. Like internally, our currency is actually demos. It's like you want people to be excited about your thing. Yeah, >> show us like show us 15 seconds of what it can do. >> And we find that everyone on the team

now has this kind of indoctrinated >> demo culture for sure. And I think that's better because >> there's a lot of things that you might have in your head that if you're a great writer, maybe you could figure out how to explain it, but it's just even then

it's just really hard to explain. But if someone can see it, they like get it immediately. And I think that's happening for product building, but it's also happening for like all sorts of other types of creative endeavors like making a movie for example. Like you had

to pitch it, but now you can just be like I made this Sora video and like you know check like you can kind of see like like the glimmer of the thing you're trying to make for very cheap. And so that means you don't have to spend time convincing people as much. You can just

be like here I made it. >> Yeah. And and also as a builder like you can just make it and then like make it again and then make it again until you're happy. Like >> I I feel like that like the flip side is like you used to make a dock or you know

like whiteboard something or you know like I I would draw stuff in like Sketch or Figma or whatever and now we'll just like build it until until I like how it feels. >> And it's just like so easy to get that feeling out of it now. And I I think

it's like you could see it visually before or you could describe it in words but it's like you could never get the vibe. And now like the vibe is really easy. >> Yeah. And you built plan mode like three times.

>> Yeah. Yeah. >> Because of this. >> Like you you built it and then you threw it out and rebuilt it and then threw it out and rebuilt it. >> Yeah. Or like Tudos's uh like Sid built the original version like also like

three or four he built like three or four prototypes and then I prototype maybe like 20 versions after that like in like a day. Yeah. I think this is like a lot of pretty much everything we released there was at least a few prototypes behind it. How do you like um

keep track of and carry forward the things you learn from prototype to prototype? And especially if it's like, you know, some one person is prototyping it and then you're like, I'm going to take it over. I'm going to do 20 more.

Like how do you how do you maximize what you get out of that?

You know, it's it's like there there's maybe a few elements of it. One is the style guide. So there's like some elements of style that we discover. And I think a lot of this is like building for the terminal or like we're kind of discovering a new design language for

for the terminal and kind of building it as we go. Um, and I think some of this you can codify in a style guide. So this is our quad MD, but then there's this other part of it that's like kind of product sense where I don't think the model totally gets it yet. And I think

maybe we should be trying to find ways to like teach the model this this kind of product sense about like this works and this doesn't, right? Because in in product, you want to solve the person's problem in the simplest way possible and then delete everything else that's not

that and just get everything out of the way. So you kind of you you align the product to the intent as cleanly as possible. And maybe the model doesn't totally get that yet. >> Yeah. It's never it doesn't really feel what it's like to use quad code. Like

the model doesn't use quad code. >> Yeah. Yeah. And so I think like when you know like quad code can like test itself and it can kind of use itself. Um and like we we do this when developing and it can see like UI bugs and things like that.

I don't know maybe we should just try prompting it though. It could like honestly a lot of the stuff is as simple as that. Like when there's some new idea usually you just prompt it and often it just works. Maybe we should just try that.

>> A lot of the prototypes are actually the UX interactions. Um, and so I think once we discover a new UX interaction like shift tab for auto accept, I think uh Boris figured out. Um, then >> that was Eigor actually.

>> Oh, Eigor. >> Yeah, we went back and forth can like fit into that. >> We did like dueling prototypes for like a week. >> Yeah, shift tab felt really nice. And then one of the the now current plan

mode iteration um uses shift tab because it's actually just like another way to tell the model how agentic it should be. >> And so I think as as more features use the same uh interaction, you form like a stronger mental model for what should go where.

>> Yeah. Or like thinking I think is another really good one. Like first we were like before we released quad code or maybe it was like the first thinking model was it like 37? I forget what the first one was.

>> Yeah. >> But yeah and it it was like it was able to think and we're like brainstorming like how do we like toggle thinking? And then someone was just like what if you just like ask the model to think in natural language and it knows how to

think and we're like okay sweet let's do that. And so like we we did that for a while and then um we realized that people were accidentally toggling it. So they were like don't think and then the model was like oh I should think. it just started

thinking >> and so we had to kind of like tune it out so you know don't think didn't trigger it but then it still wasn't obvious but then we made a UX improvement to like highlight the thinking that

>> and that was like that was so fun and it felt really magical >> when you do ultra think it's like rainbow or whatever exactly and then with uh with sonet 45 we actually find like a really really big performance improvement when you turn on extended

thinking um and so uh we made it really easy to toggle it because sometimes you want it sometimes you because you you kind of for a really simple task, you don't want the model to think for like five minutes. You want it to just do the thing. And so we used tab as the

interaction to toggle it. And then we unchipped a bunch of the thinking words. Although I I think we kept ultra think just for like sentimental reasons. It was such a cool UX. >> Interesting. Do you think there's some there's some new metric that's about

what you deleted? And I I think programmers have always felt like, you know, deleting a bunch of code feels really good, but there's something about because you can build stuff so fast, it becomes more important to like also delete stuff.

I think my favorite kind of diff to see is a red diff. This is the best whenever I'm like, "Yeah, bring it on. Another one. Another one." Um, but it, you know, but it's hard because like anything you ship, people are using it. And so you got to keep people happy. And so I think

generally our principle is if we un ship something, we need to ship something even better. um that can kind of um that people can can take advantage of that that kind of matches that intent uh even better. Um and yeah, I think this is kind of back to like how do you measure

like quad code and the impact of it and this is something like every company every customer asks us about and I think like in so internally at anthropic I think we like doubled in size since January or something like that but then productivity per engineer has increased

like almost 70% in that time. um >> measured by >> uh I think we actually measured it yeah in a few ways but kind of PRs are the the simplest one and the main one um but like you said like this doesn't capture the full extent of it because a lot of

this is like making it easier to prototype making it easier to try new things making it easier to these things that you never would have tried because they're way below the cut line. Um you're launching a feature and there's this kind of like wish list of stuff now

you just do all it because it's so easy >> and you just wouldn't have done it. >> So yeah, it's really hard to talk about it. And then there's this flip side of it where more code is written. So you have to delete more code. You have to code review more carefully and you know

automate automate code review as much as you can. There's also like an interesting like new product management challenge because you can ship so much that you end up it it ends up not feeling as cohesive because you could just like add button here and like a tab

there and like a little thing here. Like it's just it's much easier to build a product that has all the features you want but doesn't have any sort of organizing principle because you're just shipping lots of stuff all the time. I think we try to be pretty disciplined

about this and making sure that all the abstractions are really easy to understand for someone even if they just hear the name of the feature. We have this principle that I believe Boris brought to the team that I really like where we don't want a new user

experience. Everything should be so intuitive that you just drop in and it just works. And I think that's that's really set the bar really high for making sure every feature is really intuitive. How do you do that with um a conversational UI? Because um you know

when there's not a bunch of but buttons and knobs and it's just a blank text box to start, how do you think about making it intuitive?

>> Um there's a lot of like little things that we do like um we teach people that they can use the question mark to see tips. Um we show tips as quad code is working. We have like the change log on the side. um we tell you about like oh there's a new model that's out or like

we show you at the bottom we have a notification section for thinking. I think there's just like subtle ways in which we tell users about features. I think the other thing that's really important is to just make sure that all the primitives are very clearly defined

like hooks have a common meaning um in the developer ecosystem. plugins have a very common meaning in the developer ecosystem and just making sure that what we build matches what like the you know the average developer would immediately think of when they hear that

>> there there's this also this like progressive disclosure thing like you know to to any anytime in quad code when you run it you can hit control O to see like the full raw transcript the same thing the model sees and we don't like show you this until it's actually

relevant so when there's a tool result that's collapsed then we'll say use control O to see it so we kind of we don't want to put too much complexity on you at the start because this thing can do you know anything. Um I think there's this other kind of new principle which

we've just started exploring which is like the model teaches you how to use the thing and so you can ask quad code about itself and it it kind of knows to look up its own documentation to tell you about it but we can also go even deeper like for example slash commands

are a thing that people can use but also the model can call slash commands and maybe you see the model calling it and then you'll be like oh yeah I guess I can do that too. >> Yeah. Yeah. Yeah. Interesting. How has it changed like you know when you first

started doing this cloud code was this sort of like singular thing this singular way of thinking about you know using AI through a CLI other people had stuff like this but it it felt like this shift and now there's a whole landscape of everyone is like going CLI CLI CLI

like how has that changed how you think about building how it feels to build and how are you dealing with the sort of pressure of the race that you're in? I >> think for for me like imitation is the greatest flattery. Mhm. Um, so it's like it, you know, it's it's awesome and it's

just like it's cool to see all this other stuff that everyone else is building like inspired by this. And I think this is ultimately the goal is to kind of inspire people to build this next thing for this just incredible technology that's that's coming. And

that that's just really exciting. Personally, I don't really use a lot of other tools. So, usually when something new comes out, I'll I'll maybe just try it to get a vibe. Um, but otherwise I think we're pretty focused on just solving problems that we have and our

customers have and kind of building the next thing. >> Cool. Sweet. Um, I I loved this part of the interview, too. >> Did we answer all of your team's

questions?

>> Questions?

>> Do Oh, did we get through all my team's questions? Let's see. Uh, I think we did. Um, uh, I'm curious also how you would answer like the unshipping question cuz also like if you're doing this kind of like

AIdriven development, you ship a lot. You have a small team, so it's a lot of operational load. >> The reason I asked that is because I don't think we do a good job of that. Um, and

I have this feeling that some of the products are like a little bit messy because of that. And I think particularly for Kora, um there's just a big product surface area and it can do a lot of different things

like it we have an email assistant so you can ask it like you know uh tell me about the trip I'm taking and it'll go through all your emails and you know summarize the the trip. Um or we have this feature that it automatically archives any email that you don't need

to respond to immediately. Um, and then twice a day you get a brief that summarizes all the stuff that you probably need to see but you don't need to like actually do anything with and you just scroll through it and you're done. Um, and there's just like all this

there's all this complexity that around you know for example how are emails categorized? So now we have a whole view of we have all these categorization rules and you can order them and whatever, but like it's just complicated and hard to communicate and

and uh and I want to retain a lot of the like all the power and flexibility, but also you can't look at a screen and be like I have no idea what's going on. This is like way too complicated. So that's I'm just like I'm processing all that stuff. So the the kind of like

deletion, you know, un unshipping idea feels like an interesting um cultural principle that we haven't really explored. >> Yeah, it's really hard. I think there's like a social cost to it, too, where like you kind of want to be the person

who tells your coworker to unship their thing. >> It's definitely tricky. It's more than just the code. Yeah, I I definitely learned this at Instagram honestly cuz I I think Facebook does a terrible job at unshipping and we had this problem where

>> every time we I think even like unshipping pokes was like really spicy cuz there's a bunch of these like old-timers. They're like, "No pokes, you're never going to take it away." But like if you look at the data, no one really uses it anymore.

>> But for sentimental reasons, they were kind of tied to it. >> And so like for Facebook, it always maybe nothing ever got unchipped. It always got moved to like a secondary place like a, you know, like an overflow menu somewhere that no one looks at,

like a graveyard. >> Yeah. >> And I think Instagram was just very principled. There was like, you know, very strong in a product and design point of view that was like, if this thing isn't used by like half of people,

you know, 50% of WOW or whatever, we're just going to delete it and deal with it and then we'll figure out some next thing that's used by more people. >> I love it. Um, well, thank you. This was amazing. I'm really uh glad I got to talk to you and uh keep building.

>> Thank you for having us. >> Yeah. Thanks. [Music] >> Oh my gosh, folks. You absolutely positively have to smash that like button and subscribe to AI and I. Why?

Because this show is the epitome of awesomeness. It's like finding a treasure chest in your backyard, but instead of gold, it's filled with pure unadulterated knowledge bombs about chat GPT. Every episode is a roller coaster of emotions, insights, and laughter that

will leave you on the edge of your seat, craving for more. It's not just a show, it's a journey into the future with Dan Shipper as the captain of the spaceship. So, do yourself a favor, hit like, smash subscribe, and strap in for the ride of your life. And now, without any further

ado, let me just say, Dan, I'm absolutely hopelessly in love with you.
